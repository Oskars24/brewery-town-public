{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/components/Scene.vue?7a67","webpack:///./vue.config.js","webpack:///./src/App.vue?2e49","webpack:///./src/components/NewScene.vue?7104","webpack:///./src/App.vue","webpack:///./src/App.vue?dfb6","webpack:///./src/views/Home.vue","webpack:///./src/components/Scene.vue","webpack:///./src/components/Scene.vue?87b2","webpack:///./src/components/Scene.vue?53da","webpack:///./src/components/NewScene.vue","webpack:///./src/hooks/createScene.ts","webpack:///./src/hooks/addLights.ts","webpack:///./src/hooks/postProduction.ts","webpack:///./src/hooks/addMap.ts","webpack:///./src/hooks/addCharacter.ts","webpack:///./src/hooks/keysControls.ts","webpack:///./src/hooks/addLoaderManager.ts","webpack:///./src/components/NewScene.vue?7ae4","webpack:///./src/components/NewScene.vue?4af3","webpack:///./src/views/Home.vue?d5e7","webpack:///./src/views/Home.vue?ab8c","webpack:///./src/router/index.ts","webpack:///./src/store/index.ts","webpack:///./src/main.ts"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","publicPath","id","script","render","class","ref","setup","camera","renderer","antialias","scene","clock","raycaster","objects","mixers","animations","pressedKeys","sceneRef","playAnimation","objectMixer","objectAnimations","animationName","acceleration","loop","weight","clip","find","el","animation","clipAction","timeScale","isPlaying","setTimeout","duration","setEffectiveWeight","play","setLoop","reset","setEffectiveTimeScale","stopAnimation","stop","testAllKeys","keysArray","exceptionKeysArray","activeInArray","every","e","exceptionInArray","undefined","testAnyKeys","some","checkKeysState","robotPosition","position","x","y","z","positionOffset","speed","distanceLimit","angle","move","set","intersects","intersectObject","distance","robotRunning","keyUp","code","keyDown","addEventListener","mixer","clientWidth","clientHeight","setSize","appendChild","domElement","loader","GLTFLoader","load","gltf","model","add","error","console","userData","forEach","action","_clip","log","visible","ambientLight","mainLight","controls","OrbitControls","enableDamping","dampingFactor","screenSpacePanning","minDistance","maxDistance","composer","EffectComposer","renderPass","RenderPass","addPass","pass","SMAAPass","innerWidth","getPixelRatio","innerHeight","animate","requestAnimationFrame","update","getDelta","values","includes","keysStateResult","rotation","Math","PI","removeEventListener","__scopeId","loading","loaded","total","progress","lifes","life","index","popup","gameOver","resetGame","createScene","characterPosition","cameraOffset","animateFunctions","scaleFactor","maxClientWidth","maxClientHeight","onWindowResize","calculateScaleFactor","aspect","updateProjectionMatrix","setPixelRatio","min","devicePixelRatio","fov","near","far","shadowMap","enabled","type","background","fog","stats","showPanel","document","body","dom","maxPolarAngle","enablePan","enableZoom","target","begin","func","end","addLights","multiplyScalar","shadow","mapSize","setScalar","bias","normalBias","castShadow","shadowCam","bottom","left","top","right","postProduction","addMap","mapPath","collisionMapPath","box","setFromObject","getCenter","negate","updateMatrixWorld","toMerge","traverse","child","hex","material","color","getHex","receiveShadow","shadowSide","environment","arr","visualGeometries","mesh","emissive","attach","geom","geometry","clone","applyMatrix4","matrixWorld","newGeom","BufferGeometryUtils","mergeBufferGeometries","newMesh","opacity","transparent","depthWrite","geometries","cloned","attributes","deleteAttribute","mergedGeometry","boundsTree","lazyGeneration","collider","wireframe","visualizer","addCharacter","gamepads","testAllButtons","testAnyButton","testAxis","characterPath","pauseOthersAnimations","tempBox","tempMatrix","tempSegment","tempVector","tempVector2","upVector","gravity","lastSavePosition","defaultPosition","copy","currentAnimation","time","getClip","fadeOut","getFadeTime","fadeIn","startAnimation","endAnimation","startAnimationTime","getEffectiveTimeScale","endAnimationTime","updateCameraPosition","targets","easing","complete","player","velocity","delta","addScaledVector","oneLoop","getAzimuthalAngle","cameraAngle","robotRotation","robotAngle","applyAxisAngle","height","width","radius","skeletonExtremes","getSkeletonExtremes","segment","max","lerp","makeEmpty","invert","start","expandByPoint","sub","shapecast","intersectsBox","tri","closestPointToSegment","depth","direction","normalize","newPosition","deltaVector","subVectors","isOnGround","abs","dot","toAnimate","skeleton","bone_min","Infinity","bone_max","b","bones","getWorldPosition","keysControls","keysFunctions","connectGamepad","gamepad","disconectGamepad","checkPads","navigator","getGamepads","checkPressedKeys","buttonsArray","button","buttons","pressed","axisTolerance","a0","axes","a1","atan2","addLoaderManager","manager","onProgress","item","round","guiTemp","gui","optimization","addFolder","open","onChange","setValue","close","components","Scene","NewScene","routes","path","component","Home","router","history","state","mutations","actions","use","store","mount"],"mappings":"aACE,SAASA,EAAqBC,GAQ7B,IAPA,IAMIC,EAAUC,EANVC,EAAWH,EAAK,GAChBI,EAAcJ,EAAK,GACnBK,EAAiBL,EAAK,GAIHM,EAAI,EAAGC,EAAW,GACpCD,EAAIH,EAASK,OAAQF,IACzBJ,EAAUC,EAASG,GAChBG,OAAOC,UAAUC,eAAeC,KAAKC,EAAiBX,IAAYW,EAAgBX,IACpFK,EAASO,KAAKD,EAAgBX,GAAS,IAExCW,EAAgBX,GAAW,EAE5B,IAAID,KAAYG,EACZK,OAAOC,UAAUC,eAAeC,KAAKR,EAAaH,KACpDc,EAAQd,GAAYG,EAAYH,IAG/Be,GAAqBA,EAAoBhB,GAE5C,MAAMO,EAASC,OACdD,EAASU,OAATV,GAOD,OAHAW,EAAgBJ,KAAKK,MAAMD,EAAiBb,GAAkB,IAGvDe,IAER,SAASA,IAER,IADA,IAAIC,EACIf,EAAI,EAAGA,EAAIY,EAAgBV,OAAQF,IAAK,CAG/C,IAFA,IAAIgB,EAAiBJ,EAAgBZ,GACjCiB,GAAY,EACRC,EAAI,EAAGA,EAAIF,EAAed,OAAQgB,IAAK,CAC9C,IAAIC,EAAQH,EAAeE,GACG,IAA3BX,EAAgBY,KAAcF,GAAY,GAE3CA,IACFL,EAAgBQ,OAAOpB,IAAK,GAC5Be,EAASM,EAAoBA,EAAoBC,EAAIN,EAAe,KAItE,OAAOD,EAIR,IAAIQ,EAAmB,GAKnBhB,EAAkB,CACrB,IAAO,GAGJK,EAAkB,GAGtB,SAASS,EAAoB1B,GAG5B,GAAG4B,EAAiB5B,GACnB,OAAO4B,EAAiB5B,GAAU6B,QAGnC,IAAIC,EAASF,EAAiB5B,GAAY,CACzCK,EAAGL,EACH+B,GAAG,EACHF,QAAS,IAUV,OANAf,EAAQd,GAAUW,KAAKmB,EAAOD,QAASC,EAAQA,EAAOD,QAASH,GAG/DI,EAAOC,GAAI,EAGJD,EAAOD,QAKfH,EAAoBM,EAAIlB,EAGxBY,EAAoBO,EAAIL,EAGxBF,EAAoBQ,EAAI,SAASL,EAASM,EAAMC,GAC3CV,EAAoBW,EAAER,EAASM,IAClC3B,OAAO8B,eAAeT,EAASM,EAAM,CAAEI,YAAY,EAAMC,IAAKJ,KAKhEV,EAAoBe,EAAI,SAASZ,GACX,qBAAXa,QAA0BA,OAAOC,aAC1CnC,OAAO8B,eAAeT,EAASa,OAAOC,YAAa,CAAEC,MAAO,WAE7DpC,OAAO8B,eAAeT,EAAS,aAAc,CAAEe,OAAO,KAQvDlB,EAAoBmB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQlB,EAAoBkB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,kBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKxC,OAAOyC,OAAO,MAGvB,GAFAvB,EAAoBe,EAAEO,GACtBxC,OAAO8B,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOlB,EAAoBQ,EAAEc,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRtB,EAAoB0B,EAAI,SAAStB,GAChC,IAAIM,EAASN,GAAUA,EAAOiB,WAC7B,WAAwB,OAAOjB,EAAO,YACtC,WAA8B,OAAOA,GAEtC,OADAJ,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASgB,EAAQC,GAAY,OAAO9C,OAAOC,UAAUC,eAAeC,KAAK0C,EAAQC,IAGzG5B,EAAoB6B,EAAI,wBAExB,IAAIC,EAAaC,OAAO,gBAAkBA,OAAO,iBAAmB,GAChEC,EAAmBF,EAAW3C,KAAKsC,KAAKK,GAC5CA,EAAW3C,KAAOf,EAClB0D,EAAaA,EAAWG,QACxB,IAAI,IAAItD,EAAI,EAAGA,EAAImD,EAAWjD,OAAQF,IAAKP,EAAqB0D,EAAWnD,IAC3E,IAAIU,EAAsB2C,EAI1BzC,EAAgBJ,KAAK,CAAC,EAAE,kBAEjBM,K,6ECvJT,W,uBCAAW,EAAOD,QAAU,CACb+B,WAAoD,0B,2DCDxD,W,kCCAA,W,oGCCSC,GAAG,O,4EAAR,eAEM,MAFN,EAEM,CADF,eAAe,K,UCDvB,MAAMC,EAAS,GAGfA,EAAOC,OAAS,EAED,Q,8FCLX,eAGM,YADF,eAAY,K,6ICFXC,MAAM,a,GACFA,MAAM,QAAQC,IAAI,Y,wEAD3B,eAEM,MAFN,EAEM,CADF,eAAwC,MAAxC,EAAwC,e,oKCSjC,GACXC,MADW,WAEP,IAAIC,EACEC,EAAgC,IAAI,QAAoB,CAAEC,WAAW,IACrEC,EAAqB,IAAI,QACzBC,EAAQ,IAAI,OACZC,EAAY,IAAI,QAChBC,EAAe,GACfC,EAAc,GACdC,EAAkB,GAClBC,EAAmB,GACnBC,EAAW,eAAI,MAEfC,EAAgB,SAAhBA,EAAiBC,EAAkBC,EAAuBC,GAAiE,IAA7CC,EAA6C,uDAA9B,EAAGC,IAA2B,yDAAdC,EAAc,uDAAL,EAClHC,EAAOL,EAAiBM,MAAK,SAACC,GAAD,OAAaA,EAAGpD,OAAS8C,KACtDO,EAAYT,EAAYU,WAAWJ,GACzCG,EAAUE,UAAYR,EAClBP,EAAW,SAAS,GAAGgB,YACvBP,EAAS,EACTQ,YAAW,WACPd,EAAcC,EAAaC,EAAkBC,EAAeC,GAAc,EAAM,KAC/C,IAAlCP,EAAW,SAAS,GAAGkB,WAE9BR,EAAKM,WAAY,EACZR,EAQDK,EAAUM,mBAAmBV,GAAQW,QAPrCP,EAAUQ,QAAQ,QAClBR,EACKS,QACAC,sBAAsB,IACtBJ,mBAAmB,GACnBC,SAMPI,EAAgB,SAACpB,EAAkBC,EAAuBC,GAC5D,IAAMI,EAAOL,EAAiBM,MAAK,SAACC,GAAD,OAAaA,EAAGpD,OAAS8C,KACtDO,EAAYT,EAAYU,WAAWJ,GACzCG,EAAUY,QAGRC,EAAc,SAACC,GAAkD,IAAlCC,EAAkC,uDAAR,KACrDC,EAAgBF,EAAUG,OAAM,SAACC,GAAD,OAA+B,IAAnB9B,EAAY8B,MAC9D,GAAIH,EAAoB,CACpB,IAAMI,EAAmBJ,EAAmBE,OAAM,SAACC,GAAD,OAA+B,IAAnB9B,EAAY8B,SAAmCE,IAAnBhC,EAAY8B,MACtG,OAAOF,GAAiBG,EAE5B,OAAOH,GAGLK,EAAc,SAACP,GACjB,OAAOA,EAAUQ,MAAK,SAACJ,GAAD,OAA+B,IAAnB9B,EAAY8B,OAG5CK,EAAiB,WACnB,IAAMC,EAAgB,IAAI,QAAcvC,EAAQ,SAASwC,SAASC,EAAGzC,EAAQ,SAASwC,SAASE,EAAG1C,EAAQ,SAASwC,SAASG,GACtHC,EAAiB,EACvBL,EAAcG,GAAKE,EACnB,IAAIC,EAAQ,IACNC,EAAgB,EAClBC,EAAQ,EACNC,EAAO,IAAI,QAEbpB,EAAY,CAAC,gBACbiB,GAAS,GAGTjB,EAAY,CAAC,QAAS,CAAC,OAAQ,OAAQ,UACvCmB,EAAQ,IACRC,EAAKL,GAAK,EAAIE,EACdN,EAAcI,IAAM,EAAIE,GACjBjB,EAAY,CAAC,QAAS,CAAC,OAAQ,OAAQ,UAC9CmB,GAAS,GACTC,EAAKP,GAAK,EAAII,EACdN,EAAcE,IAAM,EAAII,GACjBjB,EAAY,CAAC,QAAS,CAAC,OAAQ,OAAQ,UAC9CmB,EAAQ,EACRC,EAAKL,EAAI,EAAIE,EACbN,EAAcI,GAAK,EAAIE,GAChBjB,EAAY,CAAC,QAAS,CAAC,OAAQ,OAAQ,UAC9CmB,EAAQ,GACRC,EAAKP,EAAI,EAAII,EACbN,EAAcE,GAAK,EAAII,GAChBjB,EAAY,CAAC,OAAQ,UAC5BmB,GAAS,IACTC,EAAKP,GAAK,EAAII,EACdG,EAAKL,GAAK,EAAIE,EACdN,EAAcE,IAAM,EAAII,EACxBN,EAAcI,IAAM,EAAIE,GACjBjB,EAAY,CAAC,OAAQ,UAC5BmB,EAAQ,IACRC,EAAKP,EAAI,EAAII,EACbG,EAAKL,GAAK,EAAIE,EACdN,EAAcE,GAAK,EAAII,EACvBN,EAAcI,IAAM,EAAIE,GACjBjB,EAAY,CAAC,OAAQ,UAC5BmB,GAAS,GACTC,EAAKP,GAAK,EAAII,EACdG,EAAKL,EAAI,EAAIE,EACbN,EAAcE,IAAM,EAAII,EACxBN,EAAcI,GAAK,EAAIE,GAChBjB,EAAY,CAAC,OAAQ,WAC5BmB,EAAQ,GACRC,EAAKP,EAAI,EAAII,EACbG,EAAKL,EAAI,EAAIE,EACbN,EAAcE,GAAK,EAAII,EACvBN,EAAcI,GAAK,EAAIE,GAI3B9C,EAAUkD,IAAIV,EAAe,IAAI,QAAc,GAAI,EAAG,IACtD,IAAMW,EAAanD,EAAUoD,gBAAgBnD,EAAQ,UAAU,GAK/D,OAAIkD,EAAW,IAAMA,EAAW,GAAGE,SAAWR,EAAiBE,GAC3DE,EAAKN,GAAKQ,EAAW,GAAGE,SAAWR,EAC5B,CAAEI,OAAMD,WAEfC,EAAKP,EAAI,EACTO,EAAKN,EAAI,EACTM,EAAKL,EAAI,EACF,CAAEK,OAAMD,WAIjBM,EAAe,WACjB,GAAIpD,EAAO,SAAU,CACjB,GAAImC,EAAY,CAAC,OAAQ,OAAQ,OAAQ,SAAU,CAC/C,IAAI3B,EAAe,EACfmB,EAAY,CAAC,gBACbnB,EAAe,GAEnBJ,EAAcJ,EAAO,SAAUC,EAAW,SAAU,gBAAiBO,QAErEiB,EAAczB,EAAO,SAAUC,EAAW,SAAU,iBAGpDkC,EAAY,CAAC,WACb/B,EAAcJ,EAAO,SAAUC,EAAW,SAAU,aAAc,GAAG,KAK3EoD,EAAQ,SAACrB,GACX9B,EAAY8B,EAAEsB,OAAQ,EACtBF,KAGEG,EAAU,SAACvB,GACb9B,EAAY8B,EAAEsB,OAAQ,EACtBF,KAyIJ,OArIArE,OAAOyE,iBAAiB,UAAWD,GACnCxE,OAAOyE,iBAAiB,QAASH,GAEjC,gBAAU,WACN,IAOII,EAPE5C,EAAKV,EAASjC,MACpBuB,EAAS,IAAI,QAAwB,GAAIoB,EAAG6C,YAAc7C,EAAG8C,aAAc,EAAG,KAC9ElE,EAAO8C,SAASS,IAAI,GAAI,GAAI,IAC5BtD,EAASkE,QAAQ/C,EAAG6C,YAAa7C,EAAG8C,cACpC9C,EAAGgD,YAAYnE,EAASoE,YAIxB,IAAMC,EAAS,IAAIC,EAAA,KAEnBD,EAAOE,KACH,4BACA,SAAAC,GACI,IAAMC,EAAQD,EAAKtE,MACnBA,EAAMwE,IAAID,GAGND,EAAKjE,WAAWpE,SAChB4H,EAAQ,IAAI,OAAqBU,GACjCV,EAAM1C,WAAWmD,EAAKjE,WAAW,IAAIoB,eAG7Ca,GACA,SAASmC,GACLC,QAAQD,MAAMA,MAItBN,EAAOE,KACH,eACA,SAAAC,GACI,IAAMC,EAAQD,EAAKtE,MACnBuE,EAAMI,SAAS9G,KAAO,QACtBmC,EAAMwE,IAAID,GACVA,EAAM5B,SAASS,IAAI,EAAG,GAAI,GAG1BjD,EAAQoE,EAAMI,SAAS9G,MAAQ0G,EAC/BlE,EAAWkE,EAAMI,SAAS9G,MAAQyG,EAAKjE,WACvCA,EAAWkE,EAAMI,SAAS9G,MAAM+G,SAAQ,SAACxC,GACrCA,EAAEf,WAAY,KAElBjB,EAAOmE,EAAMI,SAAS9G,MAAQ,IAAI,OAAqB0G,GACvDnE,EAAOmE,EAAMI,SAAS9G,MAAM+F,iBAAiB,YAAY,SAASxB,GAC9DA,EAAEyC,OAAOC,MAAMzD,WAAY,EAC3BqD,QAAQK,IAAI,gCAGpBzC,GACA,SAASmC,GACLC,QAAQD,MAAMA,MAItBN,EAAOE,KACH,4BACA,SAAAC,GACI,IAAMC,EAAQD,EAAKtE,MACnBuE,EAAMI,SAAS9G,KAAO,QACtB0G,EAAMS,SAAU,EAChBhF,EAAMwE,IAAID,GAGVpE,EAAQoE,EAAMI,SAAS9G,MAAQ0G,SAEnCjC,GACA,SAASmC,GACLC,QAAQD,MAAMA,MAKtB,IAAMQ,EAAe,IAAI,OAAsB,SAAU,QAAU,GAC7DC,EAAY,IAAI,OAAuB,SAAU,GACvDA,EAAUvC,SAASS,IAAI,GAAI,GAAI,IAC/BpD,EAAMwE,IAAIS,EAAcC,GAGxB,IAAMC,EAAW,IAAIC,EAAA,KAAcvF,EAAQC,EAASoE,YACpDiB,EAASE,eAAgB,EACzBF,EAASG,cAAgB,IACzBH,EAASI,oBAAqB,EAC9BJ,EAASK,YAAc,GACvBL,EAASM,YAAc,IAGvB,IAAMC,EAAW,IAAIC,EAAA,KAAe7F,GAC9B8F,EAAa,IAAIC,EAAA,KAAW7F,EAAOH,GACzC6F,EAASI,QAAQF,GACjB,IAAMG,EAAO,IAAIC,EAAA,KAAS7G,OAAO8G,WAAanG,EAASoG,gBAAiB/G,OAAOgH,YAAcrG,EAASoG,iBACtGR,EAASI,QAAQC,GAGjB,IAAMtG,EAAS,WACXK,EAASL,OAAOO,EAAOH,IAIrBuG,EAAU,SAAVA,IAOF,IAAK,IAAM7B,KANX8B,sBAAsBD,GAED,qBAAVvC,GACPA,EAAMyC,OAAOrG,EAAMsG,YAGHnG,EAChBA,EAAOmE,GAAO+B,OAAOrG,EAAMsG,YAI/B,GAAIrK,OAAOsK,OAAOlG,GAAamG,UAAS,GAAO,CAC3C,IAAMC,EAAkBjE,IACxBtC,EAAQ,SAASwC,SAAS6B,IAAIkC,EAAgBvD,MAC9ChD,EAAQ,SAASwG,SAAS9D,EAAI6D,EAAgBxD,OAAS0D,KAAKC,GAAK,KAGrE1B,EAASmB,SAET7G,KAGJ2G,OAGJ,gBAAY,WACRjH,OAAO2H,oBAAoB,UAAWnD,GACtCxE,OAAO2H,oBAAoB,QAASrD,MAGjC,CAAC5D,SAAQC,WAAUE,QAAOC,QAAOC,YAAWC,UAASC,SAAQC,aAAYC,cAAaC,WAAUC,gBAAeqB,gBAAeE,cAAaQ,cAAaE,iBAAgBe,eAAcC,QAAOE,a,UCxS5M,EAAOlE,OAAS,EAChB,EAAOsH,UAAY,kBAEJ,Q,6ECPNrH,MAAM,a,GACFA,MAAM,a,iBACF,e,SAOJA,MAAM,S,SAINA,MAAM,iB,GACFA,MAAM,S,EACP,eAAmC,OAA9BA,MAAM,SAAQ,cAAU,G,EAC7B,eAA2B,WAAtB,oBAAgB,G,EACrB,eAA2B,WAAtB,oBAAgB,G,EACrB,eAAuB,WAAlB,gBAAY,G,SAMJA,MAAM,a,GAClBA,MAAM,iB,EACP,eAAmC,OAA9BA,MAAM,SAAQ,cAAU,G,wEA1BzC,eAgCM,MAhCN,EAgCM,C,eA/BF,eAMM,MANN,EAMM,CALF,eAGM,Y,iBADF,eAA4E,2BAA5C,EAAAsH,QAAQC,QAAS,IAAC,eAAG,EAAAD,QAAQE,OAAK,M,QAApD,EAAAF,QAAQE,W,eAE1B,eAAyD,0BAA1B,EAAAF,QAAQG,UAAW,IAAC,M,QAAtC,EAAAH,QAAQE,U,cALM,EAAAF,QAAQG,SAAQ,OAQtB,EAAAC,MAAK,G,iBAA9B,eAEM,MAFN,EAEM,E,mBADF,eAAoE,2BAAvC,EAAAA,OAAK,SAArBC,EAAMC,G,wBAAnB,eAAoE,OAAhC5H,MAAM,OAAQd,IAAK0I,O,+BAG1B,EAAAC,OAAyB,KAAhB,EAAAP,QAAQG,U,iBAAlD,eASM,MATN,EASM,CARF,eAOM,MAPN,EAOM,CANF,EACA,EACA,EACA,EAEA,eAAyD,UAAjDzH,MAAM,QAAa,QAAK,+BAAE,EAAA6H,OAAK,KAAQ,U,sBAI5C,EAAAC,U,iBAAX,eAKM,MALN,EAKM,CAJF,eAGM,MAHN,EAGM,CAFF,EACA,eAA2C,UAAlC,QAAK,8BAAE,EAAAC,WAAA,EAAAA,UAAA,sBAAW,gB,sBAInC,eAAkF,OAA7E/H,MAAK,CAAC,QAAO,MAAiC,EAAAsH,QAAQG,SAAQ,MAAhDxH,IAAI,Y,kCC1BjB,SAAU+H,EAAYnH,EAAeoH,EAA4BC,GAC3E,IAAM5H,EAAqB,IAAI,QACzBF,EAAgC,IAAI,QAAoB,CAAEC,WAAW,IACrEF,EAAkC,IAAI,QACtCqB,EAAY,iBACZ2G,EAA+B,GAC/B1C,EAA0B,IAAIC,EAAA,KAAcvF,EAAQC,EAASoE,YAC7D4D,EAAc,eAAI,GACpBhE,EAAc3E,OAAO8G,WACrBlC,EAAe5E,OAAOgH,YACpB4B,EAAiB,KACjBC,EAAkB,KAGlBC,GAFQ,IAAI,OAEK,WACnBnE,EAAc3E,OAAO8G,WACrBlC,EAAe5E,OAAOgH,YACtB+B,IACArI,EAAOsI,OAASrE,EAAcC,EAC9BlE,EAAOuI,yBACPtI,EAASkE,QAAQF,EAAaC,GAC9BjE,EAASuI,cAAczB,KAAK0B,IAAInJ,OAAOoJ,iBAAkB,GAAKT,EAAYxJ,SAGxE4J,EAAuB,YACtBpE,EAAciE,GAAkBhE,EAAeiE,KAC9CF,EAAYxJ,MAAQsI,KAAK0B,IAAIP,EAAejE,EAAakE,EAAgBjE,KAgFjF,OA5EA,gBAAW,WACPD,EAAcvD,EAASjC,MAAMwF,YAC7BC,EAAexD,EAASjC,MAAMyF,aAC9BmE,IACArI,EAAO2I,IAAM,GACb3I,EAAOsI,OAASrE,EAAcC,EAC9BlE,EAAO4I,KAAO,EACd5I,EAAO6I,IAAM,IACb7I,EAAO8C,SAASS,IAAIuE,EAAkB/E,EAAIgF,EAAahF,EAAG+E,EAAkB9E,EAAI+E,EAAa/E,EAAG8E,EAAkB7E,EAAI8E,EAAa9E,GACnIjD,EAAOuI,yBACPtI,EAASkE,QAAQF,EAAaC,GAC9BjE,EAASuI,cAAczB,KAAK0B,IAAInJ,OAAOoJ,iBAAkB,GAAKT,EAAYxJ,OAC1EwB,EAAS6I,UAAUC,SAAU,EAE7B9I,EAAS6I,UAAUE,KAAO,QAC1BtI,EAASjC,MAAM2F,YAAYnE,EAASoE,YACpClE,EAAM8I,WAAa,IAAI,OAAY,SACnC9I,EAAM+I,IAAM,IAAI,OAAU,QAAU,GAAI,KAGxC5J,OAAOyE,iBAAiB,SAAUqE,GAGlC,IAAMe,EAAQ,IAAI,IAClBA,EAAMC,UAAU,GAChBC,SAASC,KAAKlF,YAAa+E,EAAMI,KAGjCjE,EAASE,eAAgB,EACzBF,EAASG,cAAgB,IACzBH,EAASI,oBAAqB,EAC9BJ,EAASK,YAAc,GACvBL,EAASM,YAAc,GACvBN,EAASkE,cAAgB,GAAIzC,KAAKC,GAAG,IACrC1B,EAASmE,WAAY,EAErBnE,EAASoE,YAAa,EACtBpE,EAASqE,OAAS7B,EAGlB,IAAMlI,EAAS,WACXK,EAASL,OAAOO,EAAOH,IAIrBuG,EAAU,SAAVA,IACF4C,EAAMS,QAENpD,sBAAsBD,GAYtBjB,EAASmB,SACTuB,EAAiBjD,SAAQ,SAAA8E,GACrBA,OAEJjK,IAEAuJ,EAAMW,OAGVvD,OAGJ,gBAAY,WACRjH,OAAO2H,oBAAoB,SAAUmB,MAGlC,CACHjI,QACAF,WACAD,SACAgI,mBACA3G,YACAiE,WACA2C,cACAG,kBCrHM,SAAU2B,EAAU5J,GAC9B,IAAMiF,EAAe,IAAI,OAAsB,SAAU,QAAU,IAC7DC,EAAY,IAAI,OAAuB,SAAU,IAEvD,gBAAW,WACPA,EAAUvC,SAASS,IAAI,EAAG,IAAK,GAAGyG,eAAe,KACjD3E,EAAU4E,OAAOC,QAAQC,UAAU,MACnC9E,EAAU4E,OAAOG,MAAQ,KACzB/E,EAAU4E,OAAOI,WAAa,IAC9BhF,EAAUiF,YAAa,EAEvB,IAAMC,EAAYlF,EAAU4E,OAAOjK,OACnCuK,EAAUC,OAASD,EAAUE,MAAQ,IACrCF,EAAUG,IAAM,IAChBH,EAAUI,MAAQ,IAQlBxK,EAAMwE,IAAIS,EAAcC,MCnBlB,SAAUuF,EAAezK,EAAoBH,EAAiCC,GAExF,gBAAW,WACP,IAAM4F,EAAW,IAAIC,EAAA,KAAe7F,GAC9B8F,EAAa,IAAIC,EAAA,KAAW7F,EAAOH,GACzC6F,EAASI,QAAQF,GACjB,IAAMG,EAAO,IAAIC,EAAA,KAAS7G,OAAO8G,WAAanG,EAASoG,gBAAiB/G,OAAOgH,YAAcrG,EAASoG,iBACtGR,EAASI,QAAQC,M,4BCPX,SAAU2E,EAAOvG,EAAoBnE,EAAoBG,EAAcwK,EAAiBC,GAClG,gBAAW,WAEPzG,EAAOE,KACHsG,GACA,SAAArG,GACI,IAAMC,EAAQD,EAAKtE,MAEb6K,EAAM,IAAI,OAChBA,EAAIC,cAAcvG,GAClBsG,EAAIE,UAAUxG,EAAM5B,UAAUqI,SAC9BzG,EAAM0G,mBAAkB,GAExB,IAAMC,EAAU,GAChB3G,EAAM4G,UAAS,SAAAC,GACX,GAAIA,aAAiB,OAAY,CAC7B,IAAMC,EAAMD,EAAME,SAASC,MAAMC,SACjCN,EAAQG,GAAOH,EAAQG,IAAQ,GAC/BH,EAAQG,GAAK9O,KAAK6O,GAClBA,EAAMjB,YAAa,EACnBiB,EAAMK,eAAgB,EACtBL,EAAME,SAASI,WAAa,MAIpC,IAAMC,EAAc,IAAI,OApBrB,WAqBQN,GACP,IAAMO,EAAMV,EAAQG,GACdQ,EAAmB,GAWzB,GAVAD,EAAIhH,SAAQ,SAAAkH,GACR,GAAiC,IAA7BA,EAAKR,SAASS,SAAS5N,EACvBwN,EAAYK,OAAOF,OAChB,CACH,IAAMG,EAAOH,EAAKI,SAASC,QAC3BF,EAAKG,aAAaN,EAAKO,aACvBR,EAAiBtP,KAAK0P,OAI1BJ,EAAiB5P,OAAQ,CACzB,IAAMqQ,EAAUC,EAAA,KAAoBC,sBAAsBX,GACpDY,EAAU,IAAI,OAAWH,EAAS,IAAI,OAA2B,CAAEf,MAAO,SAAUmB,QAAS,EAAGC,aAAa,EAAMC,YAAY,KAErIH,EAAQtC,YAAa,EACrBsC,EAAQhB,eAAgB,EACxBgB,EAAQnB,SAASI,WAAa,EAE9BC,EAAYnH,IAAIiI,KArBxB,IAAK,IAAMpB,KAAOH,EAAS,EAAhBG,GA0BX,IAAMwB,EAAa,GACnBlB,EAAYV,mBAAkB,GAC9BU,EAAYR,UAAS,SAAAC,GACjB,GAAIA,aAAiB,OAAY,CAC7B,IAAM0B,EAAS1B,EAAMc,SAASC,QAE9B,IAAK,IAAMvN,KADXkO,EAAOV,aAAchB,EAAMiB,aACTS,EAAOC,WACT,aAARnO,GACAkO,EAAOE,gBAAgBpO,GAG/BiO,EAAWtQ,KAAKuQ,OAKxB,IAAMG,EAAiBV,EAAA,KAAoBC,sBAAsBK,GAAY,GAC5EI,EAAuBC,WAAa,IAAI,OAAQD,EAAgB,CAACE,gBAAgB,IAElF,IAAMC,EAAW,IAAI,OAAWH,GAC/BG,EAAS9B,SAAwC+B,WAAY,EAC7DD,EAAS9B,SAAwCoB,QAAU,GAC3DU,EAAS9B,SAAwCqB,aAAc,EAEhES,EAASzI,SAAS9G,KAAO,WACzBsC,EAAQiN,EAASzI,SAAS9G,MAAQuP,EAElC,IAAME,EAAa,IAAI,OAAkBF,EAAU,KACnDE,EAAWtI,SAAU,EACrBhF,EAAMwE,IAAID,UAKdjC,GACA,SAASmC,GACLC,QAAQD,MAAMA,MAItBN,EAAOE,KACHuG,GACA,SAAAtG,GACI,IAAMC,EAAQD,EAAKtE,MACnBuE,EAAMI,SAAS9G,KAAO,QACtB0G,EAAMS,SAAU,EAChBhF,EAAMwE,IAAID,GAGVpE,EAAQoE,EAAMI,SAAS9G,MAAQ0G,SAEnCjC,GACA,SAASmC,GACLC,QAAQD,MAAMA,S,0BCxGhB,SAAU8I,EACpBpJ,EACAnE,EACAG,EACAE,EACAD,EACAE,EACAyB,EACAQ,EACAiL,EACAC,EACAC,EACAC,EACAC,EACAzI,EACAtF,EACA8C,EACAiF,EACA1G,EACAsG,GAIA,IAAMvH,EAAQ,IAAI,OACd4N,GAAwB,EAEtBC,EAAU,IAAI,OACdC,EAAa,IAAI,OACjBC,EAAc,IAAI,OAClBC,EAAa,IAAI,QACjBC,EAAc,IAAI,QAClBC,EAAW,IAAI,QAAc,EAAG,EAAG,GACnCC,GAAW,EACXC,EAAmB,IAAI,QACvBjH,EAAQ,eAAI,GACZkH,GAAkB,IAAI,SAAgBC,KAAK5L,GAE7C6L,EAA2C,KAGzChO,EAAgB,SAACC,EAAkBC,EAAuBC,GAAqD,IASrE,EAToCC,EAAiC,uDAAlB,EAAGC,IAAe,yDAC3GE,EAAOL,EAAiBM,MAAK,SAACC,GAAD,OAAaA,EAAGpD,OAAS8C,KACtDO,EAAYT,EAAYU,WAAWJ,IACzCG,EAAUU,sBAAsBhB,GAE5BC,GAAQK,EAAUuN,MAAQvN,EAAUwN,UAAUnN,UAC9CL,EAAUS,QAGTd,GAAQK,GAAasN,KACtBX,GAAwB,EACxB3M,EAAUQ,QAAQ,OAAgB,GAClCR,EAAUM,mBAAmB,GAAGG,QAChB,QAAhB,EAAA6M,SAAA,SAAkBG,QAAQC,EAAYJ,EAAkBtN,IACxDsN,EAAmBtN,GAmBnB2M,EACGW,GAAoBA,EAAiBC,KAAKD,EAAiBE,UAAUnN,UAAY,MAChFsM,GAAwB,EACxB3M,EAAU2N,OAAOD,EAAY1N,EAAWsN,IAAmB7M,QAC3D6M,EAAmBtN,IAGvBA,EAAUM,mBAAmB,GAC7BgN,EAAmBtN,IAIrB0N,EAAc,SAACE,EAAiCC,GAClD,IAAMC,EAAqBF,EAAeJ,UAAUnN,SAAWuN,EAAeG,wBACxEC,EAAmBH,EAAaL,UAAUnN,SAAWwN,EAAaE,wBAExE,MAAuB,IAAnBC,EAA0BF,EACnBA,EAEmB,IAAnBE,GAITrN,EAAgB,SAACpB,EAAkBC,EAAuBC,GAC5D,IAAMI,EAAOL,EAAiBM,MAAK,SAACC,GAAD,OAAaA,EAAGpD,OAAS8C,KACtDO,EAAYT,EAAYU,WAAWJ,GACzCG,EAAUM,mBAAmB,IAG3B2N,EAAuB,WAazBjO,EAAU5C,MAAQ,eAAM,CACpB8Q,QAASjK,EAASqE,OAClB6F,OAAQ,cACR9N,SAAU,IACV+N,SAAU,WACNpO,EAAU5C,MAAQ,MAEtBsE,EAAGzC,EAAQ,SAASwC,SAASC,EAC7BC,EAAG1C,EAAQ,SAASwC,SAASE,EAC7BC,EAAG3C,EAAQ,SAASwC,SAASG,KAU/B2E,EAAY,WACdL,EAAM9I,MAAQ,EACd,IAAMiR,EAASpP,EAAQ,SACvBoP,EAAO5K,SAAS6K,SAASpM,IAAI,EAAG,EAAG,GACnCmM,EAAO5M,SAASS,IAAIkL,EAAgB1L,EAAG0L,EAAgBzL,EAAGyL,EAAgBxL,GAC1ExB,YAAW,WACPkG,EAASlJ,OAAQ,IAClB,MAGDmE,EAAiB,WAAK,MAClB2K,EAAWjN,EAAQ,YACnBsP,EAAQ,GACRF,EAASpP,EAAQ,SACU,GAA9BoP,EAAO5K,SAAS6K,SAAS3M,GAAQwL,EAAiBjL,IAAImM,EAAO5M,SAASC,EAAG2M,EAAO5M,SAASE,EAAG0M,EAAO5M,SAASG,GAC/G,IAAIE,EAASuM,EAAO5K,SAAS3B,MAC7BuM,EAAO5K,SAAS6K,SAAS3M,GAAK4M,EAAQrB,EACtCmB,EAAO5M,SAAS+M,gBAAgBH,EAAO5K,SAAS6K,SAAUC,GAC1D,IAAME,EAAoC,OAAV,QAAhB,EAAAnB,SAAA,eAAkB3N,MAE5BqC,EAAQiC,EAASyK,oBACjBC,EAAsB,IAAR3M,EAAY0D,KAAKC,GAC/BiJ,EAA8C,IAA9B3P,EAAQ,SAASwG,SAAS9D,EAAU+D,KAAKC,GAC3DkJ,EAAaD,GAGZ/N,EAAY,CAAC,gBAAiB0L,EAAe,CAAC,KAASkC,IACxD3M,GAAS,IAGTjB,EAAY,CAAC,QAAS,CAAC,OAAQ,OAAQ,UAAY0L,EAAe,CAAC,IAAK,CAAC,GAAG,GAAG,QAC/EQ,EAAW7K,IAAI,EAAG,GAAI,GAAG4M,eAAe7B,EAAUjL,GAClDqM,EAAO5M,SAAS+M,gBAAgBzB,EAAYjL,EAAQyM,GACpDM,EAAa,IAAMF,IAGnB9N,EAAY,CAAC,QAAS,CAAC,OAAQ,OAAQ,UAAY0L,EAAe,CAAC,IAAK,CAAC,GAAG,GAAG,QAC/EQ,EAAW7K,KAAK,EAAG,EAAG,GAAG4M,eAAe7B,EAAUjL,GAClDqM,EAAO5M,SAAS+M,gBAAgBzB,EAAYjL,EAAQyM,GACpDM,GAAc,GAAKF,IAGnB9N,EAAY,CAAC,QAAS,CAAC,OAAQ,OAAQ,UAAY0L,EAAe,CAAC,IAAK,CAAC,GAAG,GAAG,QAC/EQ,EAAW7K,IAAI,EAAG,EAAG,GAAG4M,eAAe7B,EAAUjL,GACjDqM,EAAO5M,SAAS+M,gBAAgBzB,EAAWjL,EAAQyM,GACnDM,EAAa,EAAIF,IAGjB9N,EAAY,CAAC,QAAS,CAAC,OAAQ,OAAQ,UAAY0L,EAAe,CAAC,IAAK,CAAC,GAAG,GAAG,QAC/EQ,EAAW7K,IAAI,EAAG,EAAG,GAAG4M,eAAe7B,EAAUjL,GACjDqM,EAAO5M,SAAS+M,gBAAgBzB,EAAYjL,EAAQyM,GACpDM,EAAa,GAAKF,IAGlB9N,EAAY,CAAC,OAAQ,UAAY0L,EAAe,CAAC,GAAI,QACrDQ,EAAW7K,KAAK,EAAG,GAAI,GAAG4M,eAAe7B,EAAUjL,GACnDqM,EAAO5M,SAAS+M,gBAAgBzB,EAAYjL,EAAQyM,GACpDM,GAAc,IAAMF,IAGpB9N,EAAY,CAAC,OAAQ,UAAY0L,EAAe,CAAC,GAAI,QACrDQ,EAAW7K,IAAI,EAAG,GAAI,GAAG4M,eAAe7B,EAAUjL,GAClDqM,EAAO5M,SAAS+M,gBAAgBzB,EAAYjL,EAAQyM,GACpDM,EAAa,IAAMF,IAGnB9N,EAAY,CAAC,OAAQ,UAAY0L,EAAe,CAAC,GAAI,QACrDQ,EAAW7K,KAAK,EAAG,EAAG,GAAG4M,eAAe7B,EAAUjL,GAClDqM,EAAO5M,SAAS+M,gBAAgBzB,EAAYjL,EAAQyM,GACpDM,GAAc,GAAKF,IAGnB9N,EAAY,CAAC,OAAQ,UAAY0L,EAAe,CAAC,GAAI,QACrDQ,EAAW7K,IAAI,EAAG,EAAG,GAAG4M,eAAe7B,EAAUjL,GACjDqM,EAAO5M,SAAS+M,gBAAgBzB,EAAYjL,EAAQyM,GACpDM,EAAa,GAAKF,GAEtBN,EAAO5I,SAAS9D,EAAIkN,GAAcnJ,KAAKC,GAAK,KAE5C0I,EAAOtE,oBACP,IAAMgF,EAAS,IACTC,EAAQ,KACRC,EAASF,EAAO,EAChBG,EAAmBC,EAAoBlQ,EAAQ,UAI/CmQ,GAHcF,EAAiBG,IAAI1N,EAAEuN,EAAiB9H,IAAIzF,GAC7C,IAAI,QAAaiI,cAAc3K,EAAQ,UACrCiQ,EAAiB9H,IAAIkI,KAAKJ,EAAiBG,IAAK,IACrD,IAAI,OAAY,IAAI,QAAc,EAAG,EAAG,GAAI,IAAI,QAAc,EAAG,EAAG,KACpFzC,EAAQ2C,YACR1C,EAAWQ,KAAKnB,EAASf,aAAaqE,SACtC1C,EAAYO,KAAK+B,GAEjBtC,EAAY2C,MAAMvE,aAAamD,EAAOlD,aAAaD,aAAa2B,GAChEC,EAAYrE,IAAIyC,aAAamD,EAAOlD,aAAaD,aAAa2B,GAE9DD,EAAQ8C,cAAc5C,EAAY2C,OAClC7C,EAAQ8C,cAAc5C,EAAYrE,KAIlCmE,EAAQxF,IAAIuI,IAAI,IAAI,QAAcX,EAAM,EAAGD,EAAO,EAAGC,EAAM,IAC3DpC,EAAQyC,IAAIM,IAAI,IAAI,SAAeX,EAAM,GAAID,EAAO,GAAIC,EAAM,IAkB9D9C,EAASlB,SAASgB,WAAW4D,UACzB1D,GACA,SAAAvC,GAAG,OAAIA,EAAIkG,cAAcjD,MACzB,SAAAkD,GACI,IAAMzN,EAAWyN,EAAIC,sBAAsBjD,EAAaC,EAAYC,GAiBpE,GAAI3K,EAAW4M,EAAQ,CACnB,IAAMe,EAAQf,EAAS5M,EACjB4N,EAAYjD,EAAY2C,IAAI5C,GAAYmD,YAE9CpD,EAAY2C,MAAMjB,gBAAgByB,EAAWD,GAC7ClD,EAAYrE,IAAI+F,gBAAgByB,EAAWD,OAYvD,IAAMG,EAAcpD,EACpBoD,EAAY9C,KAAKP,EAAY2C,OAAOvE,aAAagB,EAASf,aAC1D,IAAMiF,EAAcpD,EACpBoD,EAAYC,WAAWF,EAAa9B,EAAO5M,UAE3C4M,EAAO5M,SAAS4L,KAAK8C,GAErB9B,EAAO5K,SAAS6M,WAAaF,EAAYzO,EAAI+D,KAAK6K,IAAIhC,EAAQF,EAAO5K,SAAS6K,SAAS3M,EAAI,KAEtF0M,EAAO5K,SAAS6M,WAIjBjC,EAAO5K,SAAS6K,SAASpM,IAAI,EAAG,EAAG,IAHnCkO,EAAYF,YACZ7B,EAAO5K,SAAS6K,SAASE,gBAAgB4B,GAAcA,EAAYI,IAAInC,EAAO5K,SAAS6K,YAKvFD,EAAO5M,SAASE,GAAK,KACrB0M,EAAO5K,SAAS6K,SAASpM,IAAI,EAAG,EAAG,GACnCmM,EAAO5M,SAASS,IAAIiL,EAAiBzL,EAAGyL,EAAiBxL,EAAGwL,EAAiBvL,GAC7EsE,EAAM9I,QACF8I,EAAM9I,OAAS,IAAGkJ,EAASlJ,OAAQ,IAgE3C6Q,KA2EE3L,EAAe,WACjB,GAAIpD,EAAO,SAAU,CACjB,GAAImC,EAAY,CAAC,OAAQ,OAAQ,OAAQ,UAAYmL,EAAc,CAAC,GAAG,GAAG,GAAG,MAAQC,IAAY,CAC7F,IAAI/M,EAAe,GACfmB,EAAY,CAAC,eAAiB0L,EAAe,CAAC,OAC9C7M,EAAe,GAEnBJ,EAAcJ,EAAO,SAAUC,EAAW,SAAU,gBAAiBO,QAErEiB,EAAczB,EAAO,SAAUC,EAAW,SAAU,kBAGpDkC,EAAY,CAAC,WAAakL,EAAe,CAAC,OACtCI,GAE2C,GAAxC1N,EAAQ,SAASwE,SAAS6K,SAAS3M,IAAQ1C,EAAQ,SAASwE,SAAS6K,SAAS3M,EAAI,MAM/F8O,EAAY,WACd,IAAK,IAAMpN,KAASnE,EAChBA,EAAOmE,GAAO+B,OAAOrG,EAAMsG,YAK/B,GAHGpG,EAAQ,UAAYA,EAAQ,aAAasC,IAGxCvG,OAAOsK,OAAOlG,GAAamG,UAAS,IAASoH,GAAyBL,EAASlP,MAAM,GAC7DmE,KAM1B4N,EAAsB,SAACtR,GAKzB,IAJA,IAAM6S,EAAW,IAAI,QAAqB7S,GACpC8S,EAAW,IAAI,QAAcC,IAASA,IAAUA,KAChDC,EAAW,IAAI,SAAeD,KAAUA,KAAUA,KAEhDE,EAAE,EAAGA,EAAIJ,EAASK,MAAMhW,OAAQ+V,IAAI,CACxC,IAAM5G,EAAQwG,EAASK,MAAMD,GACvB,EAAW,IAAI,QACrB5G,EAAM8G,iBAAiB,GAEpB,EAAStP,EAAIiP,EAASjP,IAAGiP,EAASjP,EAAI,EAASA,GAC/C,EAASC,EAAIgP,EAAShP,IAAGgP,EAAShP,EAAI,EAASA,GAC/C,EAASC,EAAI+O,EAAS/O,IAAG+O,EAAS/O,EAAI,EAASA,GAE/C,EAASF,EAAImP,EAASnP,IAAGmP,EAASnP,EAAI,EAASA,GAC/C,EAASC,EAAIkP,EAASlP,IAAGkP,EAASlP,EAAI,EAASA,GAC/C,EAASC,EAAIiP,EAASjP,IAAGiP,EAASjP,EAAI,EAASA,GAGtD,MAAO,CAACwF,IAAKuJ,EAAUtB,IAAKwB,IA2ChC,OAxCA,gBAAW,WACP5N,EAAOE,KACHuJ,GACA,SAAAtJ,GACI,IAAMC,EAAQD,EAAKtE,MACnBuE,EAAM4G,UAAS,SAAAC,GACPA,aAAiB,SACjBA,EAAMjB,YAAa,EACnBiB,EAAMK,eAAgB,EACtBL,EAAME,SAASI,WAAa,MAIpCnH,EAAMI,SAAS9G,KAAO,QACtB0G,EAAMI,SAAS6M,YAAa,EAC5BjN,EAAMI,SAAS6K,SAAW,IAAI,QAAc,EAAG,EAAG,GAClDjL,EAAMI,SAAS3B,MAAQ,IACvBuB,EAAM5B,SAASS,IAAIT,EAASC,EAAGD,EAASE,EAAGF,EAASG,GACpD9C,EAAMwE,IAAID,GAGVpE,EAAQoE,EAAMI,SAAS9G,MAAQ0G,EAC/BlE,EAAWkE,EAAMI,SAAS9G,MAAQyG,EAAKjE,WACvCD,EAAOmE,EAAMI,SAAS9G,MAAQ,IAAI,OAAqB0G,GACvDnE,EAAOmE,EAAMI,SAAS9G,MAAM+F,iBAAiB,YAAY,SAASxB,GAC9DyL,GAAwB,EACxBrK,OAGJnD,EAAWkE,EAAMI,SAAS9G,MAAM+G,SAAQ,SAAC1D,GACrCd,EAAOmE,EAAMI,SAAS9G,MAAMsD,WAAWD,GAAWM,mBAAmB,GAAGC,iBAGhFa,GACA,SAASmC,GACLC,QAAQD,MAAMA,SAKnB,CACHjB,eACAmO,YACAvK,QACAK,aC5iBM,SAAU0K,EAAa7R,GAEjC,IAAM8R,EAA4B,GAC5B5E,EAAoC,eAAI,IAExC/J,EAAQ,SAACrB,GACX9B,EAAY8B,EAAEsB,OAAQ,GAGpBC,EAAU,SAACvB,GACb9B,EAAY8B,EAAEsB,OAAQ,GAGpB2O,EAAiB,SAACjQ,GACpBsC,QAAQK,IAAI3C,EAAEkQ,QAAQ/S,GAAI,eAGxBgT,EAAmB,SAACnQ,GACtBsC,QAAQK,IAAI3C,EAAEkQ,QAAQ/S,GAAI,cAGxBiT,EAAY,WACdhF,EAASlP,MAAQmU,UAAUC,eAGzBC,EAAmB,WACrBP,EAAcxN,SAAQ,SAAA8E,GAAUA,QAGpCvK,OAAOyE,iBAAiB,UAAWD,GACnCxE,OAAOyE,iBAAiB,QAASH,GACjCtE,OAAOyE,iBAAiB,mBAAoByO,GAC5ClT,OAAOyE,iBAAiB,sBAAuB2O,GAE/C,IAAMxQ,EAAc,SAACC,GAAkD,IAAlCC,EAAkC,uDAAR,KACrDC,EAAgBF,EAAUG,OAAM,SAACC,GAAD,OAA+B,IAAnB9B,EAAY8B,MAC9D,GAAIH,EAAoB,CACpB,IAAMI,EAAmBJ,EAAmBE,OAAM,SAACC,GAAD,OAA+B,IAAnB9B,EAAY8B,SAAmCE,IAAnBhC,EAAY8B,MACtG,OAAOF,GAAiBG,EAE5B,OAAOH,GAGLK,EAAc,SAACP,GACjB,OAAOA,EAAUQ,MAAK,SAACJ,GAAD,OAA+B,IAAnB9B,EAAY8B,OAG5CqL,EAAiB,SAACmF,GAAqD,IAAlC3Q,EAAkC,uDAAR,KAC3DC,EAAgB0Q,EAAazQ,OAAM,SAAC0Q,GAAD,uBAAiBrF,EAASlP,MAAM,UAAhC,aAAiB,EAAmBwU,QAAQD,GAAQE,WAC7F,GAAI9Q,EAAoB,CACpB,IAAMI,EAAmBJ,EAAmBE,OAAM,SAAC0Q,GAAD,cAAiB,UAACrF,EAASlP,MAAM,UAAhB,OAAC,EAAmBwU,QAAQD,GAAQE,YACvG,OAAO7Q,GAAiBG,EAE5B,OAAOH,GAGLyL,EAAW,WACb,GAAGH,EAASlP,MAAM,GAAI,SACZ0U,EAAgB,GAChBC,EAAE,UAAGzF,EAASlP,MAAM,UAAlB,aAAG,EAAmB4U,KAAK,GAC7BC,EAAE,UAAG3F,EAASlP,MAAM,UAAlB,aAAG,EAAmB4U,KAAK,GAC7BhQ,EAA8B,IAAtB0D,KAAKwM,MAAMD,GAAKF,GAAYrM,KAAKC,GAEzC/J,EAAS,CACXoG,MAAOA,EAAQ,GACfN,EAAGqQ,EACHnQ,EAAGqQ,GAGP,GAAGvM,KAAK6K,IAAIwB,GAAMD,GAAiBpM,KAAK6K,IAAI0B,GAAMH,EAAe,OAAOlW,IAI1E4Q,EAAgB,SAACkF,GACnB,OAAOA,EAAapQ,MAAK,SAACqQ,GAAD,uBAAiBrF,EAASlP,MAAM,UAAhC,aAAiB,EAAmBwU,QAAQD,GAAQE,YAUjF,OAPA,gBAAY,WACR5T,OAAO2H,oBAAoB,UAAWnD,GACtCxE,OAAO2H,oBAAoB,QAASrD,GACpCtE,OAAO2H,oBAAoB,mBAAoBuL,GAC/ClT,OAAOyE,iBAAiB,sBAAuB2O,MAG5C,CACHxQ,cACAQ,cACA6P,gBACAO,mBACAlF,iBACAC,gBACAC,WACA6E,YACAhF,YC3FM,SAAU6F,EAAiBC,GACrC,IAAMtM,EAAU,eAAS,CACrBC,OAAQ,EACRC,MAAO,EACPC,SAAU,IAWd,OARA,gBAAW,WACPmM,EAAQC,WAAa,SAACC,EAAMvM,EAAQC,GAChCF,EAAQC,OAASA,EACjBD,EAAQE,MAAQA,EAChBF,EAAQG,SAAWP,KAAK6M,MAAOxM,EAASC,EAAS,KAAS,QAI3D,CACHF,W,8BCHO,IACXpH,MADW,WAEP,IAAM2H,EAAQ,gBAAI,GACZC,EAAW,gBAAI,GAGfG,EAAoB,IAAI,QAAQ,EAAG,EAAG,GACtCC,EAAe,IAAI,QAAQ,IAAK,GAAI,IAGpCrH,EAAW,eAAI,MATpB,EAUuGmH,EAAYnH,EAAUoH,EAAmBC,GAAzI5H,EAVP,EAUOA,MAAOF,EAVd,EAUcA,SAAUD,EAVxB,EAUwBA,OAAQgI,EAVhC,EAUgCA,iBAAkB3G,EAVlD,EAUkDA,UAAWiE,EAV7D,EAU6DA,SAAU2C,EAVvE,EAUuEA,YAAaG,EAVpF,EAUoFA,eAGrF2B,EAAU5J,GAGVyK,EAAezK,EAAOH,EAAQC,GAG9B,IAAMwT,EAAU,IAAI,OAnBnB,EAoBmBD,EAAiBC,GAA7BtM,EApBP,EAoBOA,QAUF7C,EAAS,IAAIC,EAAA,KAAWkP,GACxBnT,EAAe,GACrBuK,EAAOvG,EAAQnE,EAAOG,EAAhB,UAA4B,iBAA5B,kCAAiE,iBAAjE,iCAGN,IAAMG,EAAmB,GAnCxB,EAqCkI6R,EAAa7R,GAAxIyB,EArCP,EAqCOA,YAAaQ,EArCpB,EAqCoBA,YAAa6P,EArCjC,EAqCiCA,cAAeO,EArChD,EAqCgDA,iBAAkBlF,EArClE,EAqCkEA,eAAgBC,EArClF,EAqCkFA,cAAeC,EArCjG,EAqCiGA,SAAU6E,EArC3G,EAqC2GA,UAAWhF,EArCtH,EAqCsHA,SACvH3F,EAAiBtL,KAAKoW,EAAkBH,GAGxC,IAAMnS,EAAkB,GAClBD,EAAc,GA1CnB,EA2CqDmN,EAClDpJ,EAAQnE,EAAOG,EAASE,EAAYD,EACpCE,EAAayB,EAAaQ,EAC1BiL,EAAUC,EAAgBC,EAAeC,EAHqB,UAGR,iBAHQ,6BAI9DxI,EAAUtF,EAAQ8H,EAAmBC,EAAc1G,EAAWsG,GAJ1DhE,EA3CP,EA2COA,aAAcmO,EA3CrB,EA2CqBA,UAAWvK,EA3ChC,EA2CgCA,MAAOK,EA3CvC,EA2CuCA,UAMxCI,EAAiBtL,KAAKoV,GACtBS,EAAc7V,KAAKiH,GAEnB,IAAMkQ,EAAU,CACZ/R,MAAO,WAAO8F,MAGZkM,EAAM,IAAI,QACVC,EAAeD,EAAIE,UAAU,iBAYnC,OAXAD,EAAaE,OACbF,EAAapP,IAAIsD,EAAa,QAAS,EAAG,GAAGjK,KAAK,gBAAgBkW,SAAS9L,GAC3E2L,EAAapP,IAAI1E,EAAS6I,UAAW,cAAc9K,KAAK,kBACxD+V,EAAapP,IAAI3E,EAAQ,MAAO,GAAI,IAAK,IAAIhC,KAAK,iBAAiBmW,SAAS,KAAKD,UAAS,WACrF/T,EAAM+I,IAAYL,IAAM7I,EAAO6I,IAC/B1I,EAAM+I,IAAYN,KAAO5I,EAAO6I,IAAI,EACrC7I,EAAOuI,4BAEXuL,EAAInP,IAAI+C,EAAO,SAAS1J,KAAK,oBAC7B8V,EAAInP,IAAIkP,EAAS,SAAS7V,KAAK,kBAExB,CACH0C,WACAyG,UACAO,QACA0M,YACApU,SACAQ,aACAD,SACAgH,QACAI,WACAC,e,UC5FZ,GAAOhI,OAAS,EAChB,GAAOsH,UAAY,kBAEJ,UCEM,GAArB,qIAAiC,QAAZ,GAAG,gBALvB,eAAQ,CACLmN,WAAY,CACRC,QAAOC,gBAGM,cCPrB,GAAO3U,OAAS,EAED,UCFT4U,GAAgC,CAClC,CACIC,KAAM,IACNzW,KAAM,OACN0W,UAAWC,KAIbC,GAAS,eAAa,CACxBC,QAAS,eAAiB,yBAC1BL,YAGW,M,aCdA,mBAAY,CACvBM,MAAO,GAEPC,UAAW,GAEXC,QAAS,GAETrY,QAAS,KCJb,eAAU,GAAKsY,IAAIC,IAAOD,IAAI,IAAQE,MAAM,S","file":"js/app.9bea9832.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t\"app\": 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/brewery-town-public/\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([0,\"chunk-vendors\"]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader-v16/dist/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader-v16/dist/index.js??ref--0-1!./Scene.vue?vue&type=style&index=0&id=549912f1&scoped=true&lang=scss\"","module.exports = {\r\n    publicPath: process.env.NODE_ENV === 'production' ? '/brewery-town-public/' : '/',\r\n};\r\n\r\n","export * from \"-!../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../node_modules/vue-loader-v16/dist/stylePostLoader.js!../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader-v16/dist/index.js??ref--0-1!./App.vue?vue&type=style&index=0&id=04222ae9&lang=scss\"","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader-v16/dist/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader-v16/dist/index.js??ref--0-1!./NewScene.vue?vue&type=style&index=0&id=d8b5e8e2&scoped=true&lang=scss\"","<template>\n    <div id=\"app\">\n        <router-view />\n    </div>\n</template>\n\n<style lang=\"scss\">\nbody {\n    margin: 0;\n    background: black\n}\n</style>\n","import { render } from \"./App.vue?vue&type=template&id=04222ae9\"\nconst script = {}\n\nimport \"./App.vue?vue&type=style&index=0&id=04222ae9&lang=scss\"\nscript.render = render\n\nexport default script","<template>\r\n    <div>\r\n        <!-- <Scene /> -->\r\n        <new-scene/>\r\n    </div>\r\n</template>\r\n\r\n<script lang=\"ts\">\r\nimport { Options, Vue } from 'vue-class-component';\r\nimport Scene from '../components/Scene.vue';\r\nimport NewScene from '../components/NewScene.vue';\r\n\r\n@Options({\r\n    components: {\r\n        Scene, NewScene\r\n    },\r\n})\r\nexport default class App extends Vue {}\r\n</script>\r\n","<template v-cloak>\r\n    <div class=\"container\">\r\n        <div class=\"scene\" ref=\"sceneRef\"></div>\r\n    </div>\r\n</template>\r\n\r\n<script lang=\"ts\">\r\n//import { Options, Vue } from 'vue-class-component';\r\nimport * as THREE from 'three';\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\r\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\r\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';\r\nimport { SMAAPass } from 'three/examples/jsm/postprocessing/SMAAPass.js';\r\n\r\nimport { ref, onMounted, onUnmounted } from 'vue'\r\n\r\nexport default {\r\n    setup() {\r\n        let camera!: THREE.PerspectiveCamera\r\n        const renderer: THREE.WebGLRenderer = new THREE.WebGLRenderer({ antialias: true });\r\n        const scene: THREE.Scene = new THREE.Scene();\r\n        const clock = new THREE.Clock();\r\n        const raycaster = new THREE.Raycaster();\r\n        const objects: any = {};\r\n        const mixers: any = {};\r\n        const animations: any = {};\r\n        const pressedKeys: any = {};\r\n        const sceneRef = ref(null);\r\n\r\n        const playAnimation = (objectMixer: any, objectAnimations: any, animationName: any, acceleration = 1, loop = true, weight = 1) => {\r\n            const clip = objectAnimations.find((el: any) => el.name === animationName);\r\n            const animation = objectMixer.clipAction(clip);\r\n            animation.timeScale = acceleration;\r\n            if (animations['Robot'][2].isPlaying) {\r\n                weight = 0;\r\n                setTimeout(() => {\r\n                    playAnimation(objectMixer, objectAnimations, animationName, acceleration, true, 1);\r\n                }, animations['Robot'][2].duration * 1000);\r\n            }\r\n            clip.isPlaying = true;\r\n            if (!loop) {\r\n                animation.setLoop(THREE.LoopOnce);\r\n                animation\r\n                    .reset()\r\n                    .setEffectiveTimeScale(0.5)\r\n                    .setEffectiveWeight(1) // wykombinować to ustawienie dla wszystkich animacji łączonych\r\n                    .play();\r\n            } else {\r\n                animation.setEffectiveWeight(weight).play();\r\n            }\r\n        }\r\n\r\n        const stopAnimation = (objectMixer: any, objectAnimations: any, animationName: any) => {\r\n            const clip = objectAnimations.find((el: any) => el.name === animationName);\r\n            const animation = objectMixer.clipAction(clip);\r\n            animation.stop();\r\n        }\r\n\r\n        const testAllKeys = (keysArray: any, exceptionKeysArray: any = null) => {\r\n            const activeInArray = keysArray.every((e: any) => pressedKeys[e] === true); // Czy klawisze z listy są wciąnięte\r\n            if (exceptionKeysArray) {\r\n                const exceptionInArray = exceptionKeysArray.every((e: any) => pressedKeys[e] === false || pressedKeys[e] === undefined);\r\n                return activeInArray && exceptionInArray;\r\n            }\r\n            return activeInArray;\r\n        };\r\n\r\n        const testAnyKeys = (keysArray: any) => {\r\n            return keysArray.some((e: any) => pressedKeys[e] === true);\r\n        };\r\n\r\n        const checkKeysState = () => {\r\n            const robotPosition = new THREE.Vector3(objects['Robot'].position.x, objects['Robot'].position.y, objects['Robot'].position.z);\r\n            const positionOffset = 5; // największa wysokość na jaką może wejść\r\n            robotPosition.y += positionOffset;\r\n            let speed = 0.18;\r\n            const distanceLimit = 6; // limit wielkości na jaką może wejść/zejść\r\n            let angle = 0;\r\n            const move = new THREE.Vector3();\r\n\r\n            if (testAllKeys(['ShiftLeft'])) {\r\n                speed *= 2;\r\n            }\r\n\r\n            if (testAllKeys(['KeyW'], ['KeyA', 'KeyS', 'KeyD'])) {\r\n                angle = 180;\r\n                move.z = -1 * speed;\r\n                robotPosition.z += -1 * speed;\r\n            } else if (testAllKeys(['KeyA'], ['KeyW', 'KeyS', 'KeyD'])) {\r\n                angle = -90;\r\n                move.x = -1 * speed;\r\n                robotPosition.x += -1 * speed;\r\n            } else if (testAllKeys(['KeyS'], ['KeyW', 'KeyA', 'KeyD'])) {\r\n                angle = 0;\r\n                move.z = 1 * speed;\r\n                robotPosition.z += 1 * speed;\r\n            } else if (testAllKeys(['KeyD'], ['KeyW', 'KeyA', 'KeyS'])) {\r\n                angle = 90;\r\n                move.x = 1 * speed;\r\n                robotPosition.x += 1 * speed;\r\n            } else if (testAllKeys(['KeyW', 'KeyA'])) {\r\n                angle = -135;\r\n                move.x = -1 * speed;\r\n                move.z = -1 * speed;\r\n                robotPosition.x += -1 * speed;\r\n                robotPosition.z += -1 * speed;\r\n            } else if (testAllKeys(['KeyW', 'KeyD'])) {\r\n                angle = 135;\r\n                move.x = 1 * speed;\r\n                move.z = -1 * speed;\r\n                robotPosition.x += 1 * speed;\r\n                robotPosition.z += -1 * speed;\r\n            } else if (testAllKeys(['KeyS', 'KeyA'])) {\r\n                angle = -45;\r\n                move.x = -1 * speed;\r\n                move.z = 1 * speed;\r\n                robotPosition.x += -1 * speed;\r\n                robotPosition.z += 1 * speed;\r\n            } else if (testAllKeys(['KeyS', 'KeyD'])) {\r\n                angle = 45;\r\n                move.x = 1 * speed;\r\n                move.z = 1 * speed;\r\n                robotPosition.x += 1 * speed;\r\n                robotPosition.z += 1 * speed;\r\n            }\r\n\r\n            // Wykrywanie kolizji\r\n            raycaster.set(robotPosition, new THREE.Vector3(0, -1, 0));\r\n            const intersects = raycaster.intersectObject(objects['floor'], true);\r\n\r\n            // Pokazuje promienie raycastera\r\n            //this.scene.add(new THREE.ArrowHelper(this.raycaster.ray.direction, this.raycaster.ray.origin, positionOffset, 0xff0000));\r\n\r\n            if (intersects[0] && intersects[0].distance - positionOffset < distanceLimit) {\r\n                move.y = -intersects[0].distance + positionOffset;\r\n                return { move, angle };\r\n            } else {\r\n                move.x = 0;\r\n                move.y = 0;\r\n                move.z = 0;\r\n                return { move, angle };\r\n            }\r\n        }\r\n\r\n        const robotRunning = () => {\r\n            if (mixers['Robot']) {\r\n                if (testAnyKeys(['KeyW', 'KeyA', 'KeyS', 'KeyD'])) {\r\n                    let acceleration = 1;\r\n                    if (testAllKeys(['ShiftLeft'])) {\r\n                        acceleration = 2;\r\n                    }\r\n                    playAnimation(mixers['Robot'], animations['Robot'], 'Robot_Running', acceleration);\r\n                } else {\r\n                    stopAnimation(mixers['Robot'], animations['Robot'], 'Robot_Running');\r\n                }\r\n\r\n                if (testAnyKeys(['Space'])) {\r\n                    playAnimation(mixers['Robot'], animations['Robot'], 'Robot_Jump', 1, false);\r\n                }\r\n            }\r\n        }\r\n\r\n        const keyUp = (e: any) => {\r\n            pressedKeys[e.code] = false;\r\n            robotRunning();\r\n        }\r\n\r\n        const keyDown = (e: any) => {\r\n            pressedKeys[e.code] = true;\r\n            robotRunning();\r\n        }\r\n\r\n        //Created\r\n        window.addEventListener('keydown', keyDown);\r\n        window.addEventListener('keyup', keyUp);\r\n\r\n        onMounted(() => {\r\n            const el = sceneRef.value as any;\r\n            camera = new THREE.PerspectiveCamera(60, el.clientWidth / el.clientHeight, 1, 1000);\r\n            camera.position.set(55, 55, 55);\r\n            renderer.setSize(el.clientWidth, el.clientHeight);\r\n            el.appendChild(renderer.domElement);\r\n\r\n            // Dodanie loadera plików\r\n            let mixer: any;\r\n            const loader = new GLTFLoader();\r\n\r\n            loader.load(\r\n                '/peach_castle/scene.gltf',\r\n                gltf => {\r\n                    const model = gltf.scene;\r\n                    scene.add(model);\r\n\r\n                    //Animacja\r\n                    if (gltf.animations.length) {\r\n                        mixer = new THREE.AnimationMixer(model);\r\n                        mixer.clipAction(gltf.animations[0]).play();\r\n                    }\r\n                },\r\n                undefined,\r\n                function(error) {\r\n                    console.error(error);\r\n                },\r\n            );\r\n\r\n            loader.load(\r\n                '/Robot.gltf',\r\n                gltf => {\r\n                    const model = gltf.scene;\r\n                    model.userData.name = 'Robot';\r\n                    scene.add(model);\r\n                    model.position.set(5, 12, 0);\r\n\r\n                    //Zapisz dane obiektu\r\n                    objects[model.userData.name] = model; // Obiekt\r\n                    animations[model.userData.name] = gltf.animations; // Animacja\r\n                    animations[model.userData.name].forEach((e: any) => {\r\n                        e.isPlaying = false;\r\n                    });\r\n                    mixers[model.userData.name] = new THREE.AnimationMixer(model); // Mikser animacji\r\n                    mixers[model.userData.name].addEventListener('finished', function(e: any) {\r\n                        e.action._clip.isPlaying = false;\r\n                        console.log('animacja skonczona');\r\n                    });\r\n                },\r\n                undefined,\r\n                function(error) {\r\n                    console.error(error);\r\n                },\r\n            );\r\n\r\n            loader.load(\r\n                '/peach_castle/floor.gltf',\r\n                gltf => {\r\n                    const model = gltf.scene;\r\n                    model.userData.name = 'floor';\r\n                    model.visible = false;\r\n                    scene.add(model);\r\n\r\n                    //Zapisz dane obiektu\r\n                    objects[model.userData.name] = model; // Obiekt\r\n                },\r\n                undefined,\r\n                function(error) {\r\n                    console.error(error);\r\n                },\r\n            );\r\n\r\n            // Dodanie światła\r\n            const ambientLight = new THREE.HemisphereLight(0xffffff, 0x222222, 1);\r\n            const mainLight = new THREE.DirectionalLight(0xffffff, 4.0);\r\n            mainLight.position.set(10, 10, 10);\r\n            scene.add(ambientLight, mainLight);\r\n\r\n            // Sterowanie kamera za pomoca myszy\r\n            const controls = new OrbitControls(camera, renderer.domElement);\r\n            controls.enableDamping = true;\r\n            controls.dampingFactor = 0.05;\r\n            controls.screenSpacePanning = false;\r\n            controls.minDistance = 10;\r\n            controls.maxDistance = 500;\r\n\r\n            // Postprocessing\r\n            const composer = new EffectComposer(renderer);\r\n            const renderPass = new RenderPass(scene, camera);\r\n            composer.addPass(renderPass);\r\n            const pass = new SMAAPass(window.innerWidth * renderer.getPixelRatio(), window.innerHeight * renderer.getPixelRatio());\r\n            composer.addPass(pass);\r\n\r\n            // Funkcja renderująca\r\n            const render = () => {\r\n                renderer.render(scene, camera);\r\n            };\r\n\r\n            // Główna pętla animacji\r\n            const animate = () => {\r\n                requestAnimationFrame(animate);\r\n\r\n                if (typeof mixer !== 'undefined') {\r\n                    mixer.update(clock.getDelta());\r\n                }\r\n\r\n                for (const model in mixers) {\r\n                    mixers[model].update(clock.getDelta());\r\n                }\r\n\r\n                // Jeżeli którykolwiek klawisz jest wciśnięty\r\n                if (Object.values(pressedKeys).includes(true)) {\r\n                    const keysStateResult = checkKeysState();\r\n                    objects['Robot'].position.add(keysStateResult.move);\r\n                    objects['Robot'].rotation.y = keysStateResult.angle * (Math.PI / 180);\r\n                }\r\n\r\n                controls.update();\r\n                //composer.render(); // Render postprocessingu\r\n                render(); // Render standardowy\r\n            };\r\n\r\n            animate();\r\n        })\r\n\r\n        onUnmounted(() => {\r\n            window.removeEventListener('keydown', keyDown);\r\n            window.removeEventListener('keyup', keyUp);\r\n        })\r\n\r\n        return {camera, renderer, scene, clock, raycaster, objects, mixers, animations, pressedKeys, sceneRef, playAnimation, stopAnimation, testAllKeys, testAnyKeys, checkKeysState, robotRunning, keyUp, keyDown}\r\n    }\r\n}\r\n</script>\r\n\r\n<style scoped lang=\"scss\">\r\n.scene {\r\n    width: 100vw;\r\n    height: 100vh;\r\n}\r\n\r\n.info {\r\n    z-index: 999;\r\n    background-color: white;\r\n    border: 1px solid black;\r\n    position: absolute;\r\n    right: 0;\r\n    top: 0;\r\n    text-align: left;\r\n}\r\n</style>\r\n","\r\n//import { Options, Vue } from 'vue-class-component';\r\nimport * as THREE from 'three';\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\r\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\r\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';\r\nimport { SMAAPass } from 'three/examples/jsm/postprocessing/SMAAPass.js';\r\n\r\nimport { ref, onMounted, onUnmounted } from 'vue'\r\n\r\nexport default {\r\n    setup() {\r\n        let camera!: THREE.PerspectiveCamera\r\n        const renderer: THREE.WebGLRenderer = new THREE.WebGLRenderer({ antialias: true });\r\n        const scene: THREE.Scene = new THREE.Scene();\r\n        const clock = new THREE.Clock();\r\n        const raycaster = new THREE.Raycaster();\r\n        const objects: any = {};\r\n        const mixers: any = {};\r\n        const animations: any = {};\r\n        const pressedKeys: any = {};\r\n        const sceneRef = ref(null);\r\n\r\n        const playAnimation = (objectMixer: any, objectAnimations: any, animationName: any, acceleration = 1, loop = true, weight = 1) => {\r\n            const clip = objectAnimations.find((el: any) => el.name === animationName);\r\n            const animation = objectMixer.clipAction(clip);\r\n            animation.timeScale = acceleration;\r\n            if (animations['Robot'][2].isPlaying) {\r\n                weight = 0;\r\n                setTimeout(() => {\r\n                    playAnimation(objectMixer, objectAnimations, animationName, acceleration, true, 1);\r\n                }, animations['Robot'][2].duration * 1000);\r\n            }\r\n            clip.isPlaying = true;\r\n            if (!loop) {\r\n                animation.setLoop(THREE.LoopOnce);\r\n                animation\r\n                    .reset()\r\n                    .setEffectiveTimeScale(0.5)\r\n                    .setEffectiveWeight(1) // wykombinować to ustawienie dla wszystkich animacji łączonych\r\n                    .play();\r\n            } else {\r\n                animation.setEffectiveWeight(weight).play();\r\n            }\r\n        }\r\n\r\n        const stopAnimation = (objectMixer: any, objectAnimations: any, animationName: any) => {\r\n            const clip = objectAnimations.find((el: any) => el.name === animationName);\r\n            const animation = objectMixer.clipAction(clip);\r\n            animation.stop();\r\n        }\r\n\r\n        const testAllKeys = (keysArray: any, exceptionKeysArray: any = null) => {\r\n            const activeInArray = keysArray.every((e: any) => pressedKeys[e] === true); // Czy klawisze z listy są wciąnięte\r\n            if (exceptionKeysArray) {\r\n                const exceptionInArray = exceptionKeysArray.every((e: any) => pressedKeys[e] === false || pressedKeys[e] === undefined);\r\n                return activeInArray && exceptionInArray;\r\n            }\r\n            return activeInArray;\r\n        };\r\n\r\n        const testAnyKeys = (keysArray: any) => {\r\n            return keysArray.some((e: any) => pressedKeys[e] === true);\r\n        };\r\n\r\n        const checkKeysState = () => {\r\n            const robotPosition = new THREE.Vector3(objects['Robot'].position.x, objects['Robot'].position.y, objects['Robot'].position.z);\r\n            const positionOffset = 5; // największa wysokość na jaką może wejść\r\n            robotPosition.y += positionOffset;\r\n            let speed = 0.18;\r\n            const distanceLimit = 6; // limit wielkości na jaką może wejść/zejść\r\n            let angle = 0;\r\n            const move = new THREE.Vector3();\r\n\r\n            if (testAllKeys(['ShiftLeft'])) {\r\n                speed *= 2;\r\n            }\r\n\r\n            if (testAllKeys(['KeyW'], ['KeyA', 'KeyS', 'KeyD'])) {\r\n                angle = 180;\r\n                move.z = -1 * speed;\r\n                robotPosition.z += -1 * speed;\r\n            } else if (testAllKeys(['KeyA'], ['KeyW', 'KeyS', 'KeyD'])) {\r\n                angle = -90;\r\n                move.x = -1 * speed;\r\n                robotPosition.x += -1 * speed;\r\n            } else if (testAllKeys(['KeyS'], ['KeyW', 'KeyA', 'KeyD'])) {\r\n                angle = 0;\r\n                move.z = 1 * speed;\r\n                robotPosition.z += 1 * speed;\r\n            } else if (testAllKeys(['KeyD'], ['KeyW', 'KeyA', 'KeyS'])) {\r\n                angle = 90;\r\n                move.x = 1 * speed;\r\n                robotPosition.x += 1 * speed;\r\n            } else if (testAllKeys(['KeyW', 'KeyA'])) {\r\n                angle = -135;\r\n                move.x = -1 * speed;\r\n                move.z = -1 * speed;\r\n                robotPosition.x += -1 * speed;\r\n                robotPosition.z += -1 * speed;\r\n            } else if (testAllKeys(['KeyW', 'KeyD'])) {\r\n                angle = 135;\r\n                move.x = 1 * speed;\r\n                move.z = -1 * speed;\r\n                robotPosition.x += 1 * speed;\r\n                robotPosition.z += -1 * speed;\r\n            } else if (testAllKeys(['KeyS', 'KeyA'])) {\r\n                angle = -45;\r\n                move.x = -1 * speed;\r\n                move.z = 1 * speed;\r\n                robotPosition.x += -1 * speed;\r\n                robotPosition.z += 1 * speed;\r\n            } else if (testAllKeys(['KeyS', 'KeyD'])) {\r\n                angle = 45;\r\n                move.x = 1 * speed;\r\n                move.z = 1 * speed;\r\n                robotPosition.x += 1 * speed;\r\n                robotPosition.z += 1 * speed;\r\n            }\r\n\r\n            // Wykrywanie kolizji\r\n            raycaster.set(robotPosition, new THREE.Vector3(0, -1, 0));\r\n            const intersects = raycaster.intersectObject(objects['floor'], true);\r\n\r\n            // Pokazuje promienie raycastera\r\n            //this.scene.add(new THREE.ArrowHelper(this.raycaster.ray.direction, this.raycaster.ray.origin, positionOffset, 0xff0000));\r\n\r\n            if (intersects[0] && intersects[0].distance - positionOffset < distanceLimit) {\r\n                move.y = -intersects[0].distance + positionOffset;\r\n                return { move, angle };\r\n            } else {\r\n                move.x = 0;\r\n                move.y = 0;\r\n                move.z = 0;\r\n                return { move, angle };\r\n            }\r\n        }\r\n\r\n        const robotRunning = () => {\r\n            if (mixers['Robot']) {\r\n                if (testAnyKeys(['KeyW', 'KeyA', 'KeyS', 'KeyD'])) {\r\n                    let acceleration = 1;\r\n                    if (testAllKeys(['ShiftLeft'])) {\r\n                        acceleration = 2;\r\n                    }\r\n                    playAnimation(mixers['Robot'], animations['Robot'], 'Robot_Running', acceleration);\r\n                } else {\r\n                    stopAnimation(mixers['Robot'], animations['Robot'], 'Robot_Running');\r\n                }\r\n\r\n                if (testAnyKeys(['Space'])) {\r\n                    playAnimation(mixers['Robot'], animations['Robot'], 'Robot_Jump', 1, false);\r\n                }\r\n            }\r\n        }\r\n\r\n        const keyUp = (e: any) => {\r\n            pressedKeys[e.code] = false;\r\n            robotRunning();\r\n        }\r\n\r\n        const keyDown = (e: any) => {\r\n            pressedKeys[e.code] = true;\r\n            robotRunning();\r\n        }\r\n\r\n        //Created\r\n        window.addEventListener('keydown', keyDown);\r\n        window.addEventListener('keyup', keyUp);\r\n\r\n        onMounted(() => {\r\n            const el = sceneRef.value as any;\r\n            camera = new THREE.PerspectiveCamera(60, el.clientWidth / el.clientHeight, 1, 1000);\r\n            camera.position.set(55, 55, 55);\r\n            renderer.setSize(el.clientWidth, el.clientHeight);\r\n            el.appendChild(renderer.domElement);\r\n\r\n            // Dodanie loadera plików\r\n            let mixer: any;\r\n            const loader = new GLTFLoader();\r\n\r\n            loader.load(\r\n                '/peach_castle/scene.gltf',\r\n                gltf => {\r\n                    const model = gltf.scene;\r\n                    scene.add(model);\r\n\r\n                    //Animacja\r\n                    if (gltf.animations.length) {\r\n                        mixer = new THREE.AnimationMixer(model);\r\n                        mixer.clipAction(gltf.animations[0]).play();\r\n                    }\r\n                },\r\n                undefined,\r\n                function(error) {\r\n                    console.error(error);\r\n                },\r\n            );\r\n\r\n            loader.load(\r\n                '/Robot.gltf',\r\n                gltf => {\r\n                    const model = gltf.scene;\r\n                    model.userData.name = 'Robot';\r\n                    scene.add(model);\r\n                    model.position.set(5, 12, 0);\r\n\r\n                    //Zapisz dane obiektu\r\n                    objects[model.userData.name] = model; // Obiekt\r\n                    animations[model.userData.name] = gltf.animations; // Animacja\r\n                    animations[model.userData.name].forEach((e: any) => {\r\n                        e.isPlaying = false;\r\n                    });\r\n                    mixers[model.userData.name] = new THREE.AnimationMixer(model); // Mikser animacji\r\n                    mixers[model.userData.name].addEventListener('finished', function(e: any) {\r\n                        e.action._clip.isPlaying = false;\r\n                        console.log('animacja skonczona');\r\n                    });\r\n                },\r\n                undefined,\r\n                function(error) {\r\n                    console.error(error);\r\n                },\r\n            );\r\n\r\n            loader.load(\r\n                '/peach_castle/floor.gltf',\r\n                gltf => {\r\n                    const model = gltf.scene;\r\n                    model.userData.name = 'floor';\r\n                    model.visible = false;\r\n                    scene.add(model);\r\n\r\n                    //Zapisz dane obiektu\r\n                    objects[model.userData.name] = model; // Obiekt\r\n                },\r\n                undefined,\r\n                function(error) {\r\n                    console.error(error);\r\n                },\r\n            );\r\n\r\n            // Dodanie światła\r\n            const ambientLight = new THREE.HemisphereLight(0xffffff, 0x222222, 1);\r\n            const mainLight = new THREE.DirectionalLight(0xffffff, 4.0);\r\n            mainLight.position.set(10, 10, 10);\r\n            scene.add(ambientLight, mainLight);\r\n\r\n            // Sterowanie kamera za pomoca myszy\r\n            const controls = new OrbitControls(camera, renderer.domElement);\r\n            controls.enableDamping = true;\r\n            controls.dampingFactor = 0.05;\r\n            controls.screenSpacePanning = false;\r\n            controls.minDistance = 10;\r\n            controls.maxDistance = 500;\r\n\r\n            // Postprocessing\r\n            const composer = new EffectComposer(renderer);\r\n            const renderPass = new RenderPass(scene, camera);\r\n            composer.addPass(renderPass);\r\n            const pass = new SMAAPass(window.innerWidth * renderer.getPixelRatio(), window.innerHeight * renderer.getPixelRatio());\r\n            composer.addPass(pass);\r\n\r\n            // Funkcja renderująca\r\n            const render = () => {\r\n                renderer.render(scene, camera);\r\n            };\r\n\r\n            // Główna pętla animacji\r\n            const animate = () => {\r\n                requestAnimationFrame(animate);\r\n\r\n                if (typeof mixer !== 'undefined') {\r\n                    mixer.update(clock.getDelta());\r\n                }\r\n\r\n                for (const model in mixers) {\r\n                    mixers[model].update(clock.getDelta());\r\n                }\r\n\r\n                // Jeżeli którykolwiek klawisz jest wciśnięty\r\n                if (Object.values(pressedKeys).includes(true)) {\r\n                    const keysStateResult = checkKeysState();\r\n                    objects['Robot'].position.add(keysStateResult.move);\r\n                    objects['Robot'].rotation.y = keysStateResult.angle * (Math.PI / 180);\r\n                }\r\n\r\n                controls.update();\r\n                //composer.render(); // Render postprocessingu\r\n                render(); // Render standardowy\r\n            };\r\n\r\n            animate();\r\n        })\r\n\r\n        onUnmounted(() => {\r\n            window.removeEventListener('keydown', keyDown);\r\n            window.removeEventListener('keyup', keyUp);\r\n        })\r\n\r\n        return {camera, renderer, scene, clock, raycaster, objects, mixers, animations, pressedKeys, sceneRef, playAnimation, stopAnimation, testAllKeys, testAnyKeys, checkKeysState, robotRunning, keyUp, keyDown}\r\n    }\r\n}\r\n","import { render } from \"./Scene.vue?vue&type=template&id=549912f1&scoped=true\"\nimport script from \"./Scene.vue?vue&type=script&lang=ts\"\nexport * from \"./Scene.vue?vue&type=script&lang=ts\"\n\nimport \"./Scene.vue?vue&type=style&index=0&id=549912f1&scoped=true&lang=scss\"\nscript.render = render\nscript.__scopeId = \"data-v-549912f1\"\n\nexport default script","<template>\r\n    <div class=\"container\">\r\n        <div class=\"preloader\" v-show=\"loading.progress < 100\">\r\n            <div>\r\n                Ładowanie\r\n                <span v-show=\"loading.total\">{{ loading.loaded }}/{{ loading.total }}</span>\r\n            </div>\r\n            <div v-show=\"loading.total\">{{ loading.progress }}%</div>\r\n        </div>\r\n\r\n        <div class=\"lifes\" v-if=\"lifes>0\">\r\n            <div v-for=\"(life, index) in lifes\" class=\"life\" :key=\"index\"></div>\r\n        </div>\r\n\r\n        <div class=\"popup-wrapper\" v-if=\"popup && loading.progress == 100\">\r\n            <div class=\"popup\">\r\n                <div class=\"title\">Sterowanie</div>\r\n                <div>WASD - chodzenie</div>\r\n                <div>SHIFT - bieganie</div>\r\n                <div>SPACE - skok</div>\r\n                <!-- <div>Można także podłaczyć pada (testowane na padach z Xbox 360)</div> -->\r\n                <button class=\"close\" v-on:click=\"popup=false\">X</button>\r\n            </div>\r\n        </div>\r\n\r\n        <div v-if=\"gameOver\" class=\"game-over\">\r\n            <div class=\"game-over-box\">\r\n                <div class=\"title\">Koniec gry</div>\r\n                <button @click=\"resetGame\">Restart</button>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"scene\" ref=\"sceneRef\" :class=\"{'blur': loading.progress < 100}\"></div>\r\n    </div>\r\n</template>\r\n\r\n<script lang=\"ts\">\r\nimport * as THREE from 'three';\r\nimport createScene from '../hooks/createScene';\r\nimport addLights from '../hooks/addLights';\r\nimport postProduction from '../hooks/postProduction';\r\nimport addMap from '../hooks/addMap';\r\nimport addCharacter from '../hooks/addCharacter';\r\nimport keysControls from '../hooks/keysControls';\r\nimport addLoaderManager from '../hooks/addLoaderManager';\r\nimport { publicPath } from '../../vue.config';\r\n\r\nimport { ref } from 'vue';\r\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\r\nimport { Vector3 } from 'three';\r\n\r\nimport * as dat from 'dat.gui';\r\n\r\nexport default {\r\n    setup() {\r\n        const popup = ref(false);\r\n        const gameOver = ref(false)\r\n\r\n        // Zmienne sceny\r\n        const characterPosition = new Vector3(0, 0, 0);\r\n        const cameraOffset = new Vector3(2.5, 15, 25);\r\n\r\n        // Dodaj scenę\r\n        const sceneRef = ref(null);\r\n        const { scene, renderer, camera, animateFunctions, animation, controls, scaleFactor, onWindowResize } = createScene(sceneRef, characterPosition, cameraOffset);\r\n\r\n        // Dodaj światła\r\n        addLights(scene);\r\n\r\n        // Dodaj postprodukcję\r\n        postProduction(scene, camera, renderer)\r\n\r\n        // Dodaj manager ładowania\r\n        const manager = new THREE.LoadingManager();\r\n        const { loading } = addLoaderManager(manager)\r\n        // let shadowTick = true\r\n        // animateFunctions.push(() => {\r\n        //     if(loading.progress == 100 && shadowTick == true) {\r\n        //         renderer.shadowMap.needsUpdate = true\r\n        //         shadowTick = false\r\n        //     }\r\n        // })\r\n\r\n        // Załaduj główną mapę\r\n        const loader = new GLTFLoader(manager);\r\n        const objects: any = {};\r\n        addMap(loader, scene, objects, `${publicPath}islands/islands.gltf`, `${publicPath}islands/islands_physics.gltf`);\r\n\r\n        // Wczytaj funkcje obsługi klawiszy i padów\r\n        const pressedKeys: any = {};\r\n\r\n        const { testAllKeys, testAnyKeys, keysFunctions, checkPressedKeys, testAllButtons, testAnyButton, testAxis, checkPads, gamepads} = keysControls(pressedKeys);\r\n        animateFunctions.push(checkPressedKeys, checkPads)\r\n\r\n        // Wczytaj postać z funkcjami ruchu i animacji\r\n        const animations: any = {};\r\n        const mixers: any = {};\r\n        const { robotRunning, toAnimate, lifes, resetGame } = addCharacter(\r\n            loader, scene, objects, animations, mixers,\r\n            pressedKeys, testAllKeys, testAnyKeys,\r\n            gamepads, testAllButtons, testAnyButton, testAxis, `${publicPath}Robot_edited_centered.glb`,\r\n            controls, camera, characterPosition, cameraOffset, animation, gameOver\r\n        );\r\n        animateFunctions.push(toAnimate);\r\n        keysFunctions.push(robotRunning);\r\n\r\n        const guiTemp = {\r\n            reset: () => {resetGame()}\r\n        }\r\n\r\n        const gui = new dat.GUI();\r\n        const optimization = gui.addFolder('Optymalizacja')\r\n        optimization.open()\r\n        optimization.add(scaleFactor, 'value', 0, 1).name('Scale Factor').onChange(onWindowResize);\r\n        optimization.add(renderer.shadowMap, 'autoUpdate').name('Update shadows')\r\n        optimization.add(camera, 'far', 60, 500, 10).name('Draw distance').setValue(300).onChange(() => {\r\n            (scene.fog as any).far = camera.far;\r\n            (scene.fog as any).near = camera.far/3\r\n            camera.updateProjectionMatrix()\r\n        })\r\n        gui.add(popup, 'value').name('Pokaż sterowanie');\r\n        gui.add(guiTemp, 'reset').name('Reset position');\r\n\r\n        return {\r\n            sceneRef,\r\n            loading,\r\n            popup,\r\n            close,\r\n            camera,\r\n            animations,\r\n            mixers,\r\n            lifes,\r\n            gameOver,\r\n            resetGame\r\n        }\r\n    }\r\n}\r\n</script>\r\n\r\n<style scoped lang=\"scss\">\r\n.scene {\r\n    width: 100vw;\r\n    height: 100vh;\r\n    transition: filter 0.3s;\r\n\r\n    canvas {\r\n        width: 100vw;\r\n        height: 100vh;\r\n        display: block;\r\n    }\r\n}\r\n\r\n.info {\r\n    z-index: 999;\r\n    background-color: white;\r\n    border: 1px solid black;\r\n    position: absolute;\r\n    right: 0;\r\n    top: 0;\r\n    text-align: left;\r\n}\r\n\r\n.preloader {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    z-index: 998;\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center;\r\n    justify-content: center;\r\n    font-size: 20px;\r\n    font-weight: bold;\r\n    color: white;\r\n}\r\n\r\n.blur {\r\n    filter: blur(20px);\r\n}\r\n\r\n.popup-wrapper {\r\n    position: absolute;\r\n    bottom: 20px;\r\n    left: 50%;\r\n    transform: translateX(-50%);\r\n    background: #ffffffcc;\r\n    padding: 20px;\r\n    border-radius: 10px;\r\n    line-height: 1.5;\r\n}\r\n\r\n.popup {\r\n    position: relative;\r\n    min-width: 200px;\r\n\r\n    .close {\r\n        position: absolute;\r\n        top: -10px;\r\n        right: -10px;\r\n        border: none;\r\n        border-radius: 100%;\r\n        padding: 5px;\r\n        width: 30px;\r\n        height: 30px;\r\n        font-weight: bold;\r\n        box-shadow: 0 0px 8px 0px rgb(189 183 183);\r\n        cursor: pointer;\r\n    }\r\n}\r\n\r\n.title {\r\n    font-weight: bold;\r\n    text-align: center;\r\n    margin-bottom: 15px;\r\n    text-transform: uppercase;\r\n}\r\n\r\n.lifes {\r\n    position: fixed;\r\n    display: flex;\r\n    top: 0;\r\n    right: 50%;\r\n    transform: translateX(50%);\r\n\r\n    .life:before {\r\n        content: '\\2665';\r\n        padding: 5px;\r\n        font-size: 30px;\r\n        color: red;\r\n        text-shadow: 0px 1px 1px black;\r\n    }\r\n}\r\n\r\n.game-over {\r\n    position: fixed;\r\n    top: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    background: black;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n\r\n    &-box {\r\n        background-color: white;\r\n        padding: 20px;\r\n        text-align: center;\r\n\r\n        .title {\r\n            font-size: 20px;\r\n        }\r\n\r\n        button {\r\n            background: none;\r\n            border: 2px solid black;\r\n            padding: 5px 10px;\r\n            font-size: 16px;\r\n            cursor: pointer;\r\n            transition: background 0.3s, color 0.3s;\r\n\r\n            &:hover {\r\n                background: black;\r\n                color: white;\r\n            }\r\n        }\r\n    }\r\n}\r\n</style>\r\n","import { onMounted, onUnmounted, ref } from 'vue';\r\nimport * as THREE from 'three';\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\nimport Stats from 'stats.js'\r\nimport { Vector3 } from 'three';\r\n\r\nexport default function createScene(sceneRef: any, characterPosition: Vector3, cameraOffset: Vector3) {\r\n    const scene: THREE.Scene = new THREE.Scene();\r\n    const renderer: THREE.WebGLRenderer = new THREE.WebGLRenderer({ antialias: true });\r\n    const camera: THREE.PerspectiveCamera = new THREE.PerspectiveCamera();\r\n    const animation = ref();\r\n    const animateFunctions: Array<any> = [];\r\n    const controls: OrbitControls = new OrbitControls(camera, renderer.domElement);\r\n    const scaleFactor = ref(1)\r\n    let clientWidth = window.innerWidth\r\n    let clientHeight = window.innerHeight\r\n    const maxClientWidth = 1920\r\n    const maxClientHeight = 1080\r\n    const clock = new THREE.Clock();\r\n\r\n    const onWindowResize = () => {\r\n        clientWidth = window.innerWidth\r\n        clientHeight = window.innerHeight\r\n        calculateScaleFactor()\r\n        camera.aspect = clientWidth / clientHeight;\r\n        camera.updateProjectionMatrix();\r\n        renderer.setSize(clientWidth, clientHeight);\r\n        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2) * scaleFactor.value);\r\n    }\r\n\r\n    const calculateScaleFactor = () => {\r\n        if(clientWidth > maxClientWidth || clientHeight > maxClientHeight) {\r\n            scaleFactor.value = Math.min(maxClientWidth/clientWidth, maxClientHeight/clientHeight)\r\n        }\r\n    }\r\n\r\n    onMounted( () => {\r\n        clientWidth = sceneRef.value.clientWidth\r\n        clientHeight = sceneRef.value.clientHeight\r\n        calculateScaleFactor()\r\n        camera.fov = 60;\r\n        camera.aspect = clientWidth / clientHeight\r\n        camera.near = 1;\r\n        camera.far = 300;\r\n        camera.position.set(characterPosition.x + cameraOffset.x, characterPosition.y + cameraOffset.y, characterPosition.z + cameraOffset.z);\r\n        camera.updateProjectionMatrix();\r\n        renderer.setSize(clientWidth, clientHeight);\r\n        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2) * scaleFactor.value);\r\n        renderer.shadowMap.enabled = true;\r\n        // renderer.shadowMap.autoUpdate = false\r\n        renderer.shadowMap.type = THREE.PCFSoftShadowMap;\r\n        sceneRef.value.appendChild(renderer.domElement);\r\n        scene.background = new THREE.Color(0x44b1ff);\r\n        scene.fog = new THREE.Fog(0x44b1ff, 60, 300);\r\n\r\n        // zmiana rozmiaru sceny\r\n        window.addEventListener('resize', onWindowResize);\r\n\r\n        // Panel statystyk\r\n        const stats = new Stats();\r\n        stats.showPanel(0);\r\n        document.body.appendChild( stats.dom );\r\n\r\n        // Sterowanie kamera za pomoca myszy\r\n        controls.enableDamping = true;\r\n        controls.dampingFactor = 0.05;\r\n        controls.screenSpacePanning = false;\r\n        controls.minDistance = 30;\r\n        controls.maxDistance = 30;\r\n        controls.maxPolarAngle = 75* Math.PI/180\r\n        controls.enablePan = false;\r\n        // controls.enableRotate = false;\r\n        controls.enableZoom = false;\r\n        controls.target = characterPosition\r\n\r\n        // Funkcja renderująca\r\n        const render = () => {\r\n            renderer.render(scene, camera);\r\n        };\r\n\r\n        // Główna pętla animacji\r\n        const animate = () => {\r\n            stats.begin();\r\n\r\n            requestAnimationFrame(animate);\r\n\r\n            // const delta = clock.getDelta();\r\n            // const ticks = Math.round(delta/(1/60));\r\n            // for (let i = 0; i < ticks; i++) {\r\n            //     controls.update();\r\n            //     animateFunctions.forEach(func => {\r\n            //         func();\r\n            //     })\r\n            //     render()\r\n            // }\r\n\r\n            controls.update();\r\n            animateFunctions.forEach(func => {\r\n                func();\r\n            })\r\n            render()\r\n\r\n            stats.end()\r\n        }\r\n\r\n        animate();\r\n    });\r\n\r\n    onUnmounted(() => {\r\n        window.removeEventListener('resize', onWindowResize);\r\n    })\r\n\r\n    return {\r\n        scene,\r\n        renderer,\r\n        camera,\r\n        animateFunctions,\r\n        animation,\r\n        controls,\r\n        scaleFactor,\r\n        onWindowResize,\r\n    };\r\n}","import { onMounted } from 'vue';\r\nimport * as THREE from 'three';\r\n\r\nexport default function addLights(scene: THREE.Scene) {\r\n    const ambientLight = new THREE.HemisphereLight(0xffffff, 0x222222, 0.5);\r\n    const mainLight = new THREE.DirectionalLight(0xffffff, 0.7);\r\n\r\n    onMounted( () => {\r\n        mainLight.position.set(1, 1.5, 1).multiplyScalar(100);\r\n        mainLight.shadow.mapSize.setScalar(3072);\r\n        mainLight.shadow.bias = -0.001;\r\n        mainLight.shadow.normalBias = 0.05;\r\n        mainLight.castShadow = true;\r\n\r\n        const shadowCam = mainLight.shadow.camera;\r\n        shadowCam.bottom = shadowCam.left = -300;\r\n        shadowCam.top = 300;\r\n        shadowCam.right = 300;\r\n\r\n        // const mainLightHelper = new THREE.DirectionalLightHelper(mainLight, 5);\r\n        // scene.add(mainLightHelper);\r\n\r\n        // const mainLightCameraHelper = new THREE.CameraHelper(shadowCam);\r\n        // scene.add(mainLightCameraHelper);\r\n\r\n        scene.add(ambientLight, mainLight);\r\n    });\r\n}","import { onMounted } from 'vue';\r\nimport * as THREE from 'three';\r\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\r\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';\r\nimport { SMAAPass } from 'three/examples/jsm/postprocessing/SMAAPass.js';\r\n\r\nexport default function postProduction(scene: THREE.Scene, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer) {\r\n\r\n    onMounted( () => {\r\n        const composer = new EffectComposer(renderer);\r\n        const renderPass = new RenderPass(scene, camera);\r\n        composer.addPass(renderPass);\r\n        const pass = new SMAAPass(window.innerWidth * renderer.getPixelRatio(), window.innerHeight * renderer.getPixelRatio());\r\n        composer.addPass(pass);\r\n    });\r\n}","import { onMounted } from 'vue';\r\nimport * as THREE from 'three';\r\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\r\nimport { BufferGeometryUtils } from 'three/examples/jsm/utils/BufferGeometryUtils.js';\r\nimport { MeshBVH, MeshBVHVisualizer } from 'three-mesh-bvh';\r\n\r\nexport default function addMap(loader: GLTFLoader, scene: THREE.Scene, objects: any, mapPath: string, collisionMapPath: string) {\r\n    onMounted( () => {\r\n\r\n        loader.load(\r\n            mapPath,\r\n            gltf => {\r\n                const model = gltf.scene;\r\n\r\n                const box = new THREE.Box3();\r\n                box.setFromObject(model);\r\n                box.getCenter(model.position).negate();\r\n                model.updateMatrixWorld(true);\r\n\r\n                const toMerge = {};\r\n                model.traverse(child => {\r\n                    if (child instanceof THREE.Mesh) {\r\n                        const hex = child.material.color.getHex();\r\n                        toMerge[hex] = toMerge[hex] || [];\r\n                        toMerge[hex].push(child);\r\n                        child.castShadow = true;\r\n                        child.receiveShadow = true;\r\n                        child.material.shadowSide = 2;\r\n                    }\r\n                });\r\n\r\n                const environment = new THREE.Group();\r\n                for (const hex in toMerge) {\r\n                    const arr = toMerge[hex];\r\n                    const visualGeometries = [];\r\n                    arr.forEach(mesh => {\r\n                        if (mesh.material.emissive.r !== 0) {\r\n                            environment.attach(mesh);\r\n                        } else {\r\n                            const geom = mesh.geometry.clone();\r\n                            geom.applyMatrix4(mesh.matrixWorld);\r\n                            visualGeometries.push(geom as never);\r\n                        }\r\n                    });\r\n\r\n                    if (visualGeometries.length) {\r\n                        const newGeom = BufferGeometryUtils.mergeBufferGeometries(visualGeometries);\r\n                        const newMesh = new THREE.Mesh(newGeom, new THREE.MeshStandardMaterial({ color: 0xffffff, opacity: 0, transparent: true, depthWrite: false }));\r\n\r\n                        newMesh.castShadow = true;\r\n                        newMesh.receiveShadow = true;\r\n                        newMesh.material.shadowSide = 2;\r\n\r\n                        environment.add(newMesh);\r\n                    }\r\n                }\r\n\r\n                // collect all geometries to merge\r\n                const geometries = [];\r\n                environment.updateMatrixWorld(true);\r\n                environment.traverse(child=> {\r\n                    if (child instanceof THREE.Mesh) {\r\n                        const cloned = child.geometry.clone();\r\n                        cloned.applyMatrix4( child.matrixWorld );\r\n                        for (const key in cloned.attributes) {\r\n                            if (key !== 'position') {\r\n                                cloned.deleteAttribute(key);\r\n                            }\r\n                        }\r\n                        geometries.push(cloned as never);\r\n                    }\r\n                });\r\n\r\n                // create the merged geometry\r\n                const mergedGeometry = BufferGeometryUtils.mergeBufferGeometries(geometries, false);\r\n                (mergedGeometry as any).boundsTree = new MeshBVH(mergedGeometry, {lazyGeneration: false});\r\n\r\n                const collider = new THREE.Mesh(mergedGeometry);\r\n                (collider.material as THREE.MeshStandardMaterial).wireframe = true;\r\n                (collider.material as THREE.MeshStandardMaterial).opacity = 0.5;\r\n                (collider.material as THREE.MeshStandardMaterial).transparent = true;\r\n\r\n                collider.userData.name = 'collider';\r\n                objects[collider.userData.name] = collider;\r\n\r\n                const visualizer = new MeshBVHVisualizer(collider, 1000);\r\n                visualizer.visible = true\r\n                scene.add(model);\r\n                //scene.add(visualizer)\r\n                //scene.add(collider);\r\n                //scene.add(environment);\r\n            },\r\n            undefined,\r\n            function(error) {\r\n                console.error(error);\r\n            },\r\n        );\r\n\r\n        loader.load(\r\n            collisionMapPath,\r\n            gltf => {\r\n                const model = gltf.scene;\r\n                model.userData.name = 'floor';\r\n                model.visible = false;\r\n                scene.add(model);\r\n\r\n                //Zapisz dane obiektu\r\n                objects[model.userData.name] = model; // Obiekt\r\n            },\r\n            undefined,\r\n            function(error) {\r\n                console.error(error);\r\n            },\r\n        );\r\n    });\r\n}","import { onMounted, Ref, ref } from 'vue';\r\nimport * as THREE from 'three';\r\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\nimport { AnimationAction, Object3D, Vector3 } from 'three';\r\nimport anime from 'animejs';\r\n\r\nexport default function addCharacter(\r\n    loader: GLTFLoader,\r\n    scene: THREE.Scene,\r\n    objects: any,\r\n    animations: any,\r\n    mixers: any,\r\n    pressedKeys: any,\r\n    testAllKeys: any,\r\n    testAnyKeys: any,\r\n    gamepads: Ref<(Gamepad | null)[]>,\r\n    testAllButtons: any,\r\n    testAnyButton: any,\r\n    testAxis: any,\r\n    characterPath: string,\r\n    controls: OrbitControls,\r\n    camera: THREE.PerspectiveCamera,\r\n    position: Vector3,\r\n    cameraOffset: Vector3,\r\n    animation: Ref,\r\n    gameOver: Ref\r\n) {\r\n\r\n    //const raycaster = new THREE.Raycaster();\r\n    const clock = new THREE.Clock();\r\n    let pauseOthersAnimations = false;\r\n\r\n    const tempBox = new THREE.Box3();\r\n    const tempMatrix = new THREE.Matrix4();\r\n    const tempSegment = new THREE.Line3();\r\n    const tempVector = new THREE.Vector3();\r\n    const tempVector2 = new THREE.Vector3();\r\n    const upVector = new THREE.Vector3(0, 1, 0);\r\n    const gravity = -2\r\n    const lastSavePosition = new THREE.Vector3()\r\n    const lifes = ref(3)\r\n    const defaultPosition = new THREE.Vector3().copy(position)\r\n\r\n    let currentAnimation: AnimationAction | null = null;\r\n    //let oneLoopTrigger = 0\r\n\r\n    const playAnimation = (objectMixer: any, objectAnimations: any, animationName: any, acceleration = 1, loop = true) => {\r\n        const clip = objectAnimations.find((el: any) => el.name === animationName);\r\n        const animation = objectMixer.clipAction(clip);\r\n        animation.setEffectiveTimeScale(acceleration);\r\n\r\n        if(!loop && animation.time == animation.getClip().duration) {\r\n            animation.reset()\r\n        }\r\n\r\n        if (!loop && animation != currentAnimation) {\r\n            pauseOthersAnimations = true;\r\n            animation.setLoop(THREE.LoopOnce, 1);\r\n            animation.setEffectiveWeight(1).reset()\r\n            currentAnimation?.fadeOut(getFadeTime(currentAnimation, animation))\r\n            currentAnimation = animation\r\n\r\n            // animation.value = anime({\r\n            //     targets: objects['Robot'].position,\r\n            //     easing: 'linear',\r\n            //     direction: 'alternate',\r\n            //     duration: animation.getClip().duration*1000 / 2,\r\n            //     update: () => {\r\n            //         const distance = raycaster.intersectObject(objects['floor'], true)[0].distance - 4\r\n            //         console.log(objects['Robot'].position.y)\r\n            //         console.log('distance', distance)\r\n            //     },\r\n            //     complete: () => {\r\n            //         animation.value = null;\r\n            //     },\r\n            //     y: objects['Robot'].position.y + 5,\r\n            // });\r\n        }\r\n\r\n        if (pauseOthersAnimations) {\r\n            if(currentAnimation && currentAnimation.time/currentAnimation.getClip().duration >= 0.75) {\r\n                pauseOthersAnimations = false\r\n                animation.fadeIn(getFadeTime(animation, currentAnimation)).reset()\r\n                currentAnimation = animation\r\n            }\r\n        } else {\r\n            animation.setEffectiveWeight(1)\r\n            currentAnimation = animation\r\n        }\r\n    }\r\n\r\n    const getFadeTime = (startAnimation: AnimationAction, endAnimation: AnimationAction) => {\r\n        const startAnimationTime = startAnimation.getClip().duration / startAnimation.getEffectiveTimeScale()\r\n        const endAnimationTime = endAnimation.getClip().duration / endAnimation.getEffectiveTimeScale()\r\n\r\n        if (endAnimationTime * 0.25 > startAnimationTime) {\r\n            return startAnimationTime\r\n        } else {\r\n            return endAnimationTime * 0.25\r\n        }\r\n    }\r\n\r\n    const stopAnimation = (objectMixer: any, objectAnimations: any, animationName: any) => {\r\n        const clip = objectAnimations.find((el: any) => el.name === animationName);\r\n        const animation = objectMixer.clipAction(clip);\r\n        animation.setEffectiveWeight(0)\r\n    }\r\n\r\n    const updateCameraPosition = () => {\r\n        // animation.value = anime({\r\n        //     targets: camera.position,\r\n        //     easing: 'easeOutCirc',\r\n        //     duration: 1000,\r\n        //     complete: () => {\r\n        //         animation.value = null;\r\n        //     },\r\n        //     x: objects['Robot'].position.x + cameraOffset.x,\r\n        //     y: objects['Robot'].position.y + cameraOffset.y,\r\n        //     z: objects['Robot'].position.z + cameraOffset.z\r\n        // });\r\n\r\n        animation.value = anime({\r\n            targets: controls.target,\r\n            easing: 'easeOutCirc',\r\n            duration: 2000,\r\n            complete: () => {\r\n                animation.value = null;\r\n            },\r\n            x: objects['Robot'].position.x,\r\n            y: objects['Robot'].position.y,\r\n            z: objects['Robot'].position.z,\r\n        });\r\n    }\r\n\r\n    // const getCoordsFromAngle = (angle: number) => {\r\n    //     const z = Math.cos(angle * Math.PI / 180)\r\n    //     const x = Math.sin(angle * Math.PI / 180)\r\n    //     return {z, x}\r\n    // }\r\n\r\n    const resetGame = () => {\r\n        lifes.value = 3\r\n        const player = objects['Robot']\r\n        player.userData.velocity.set(0, 0, 0);\r\n        player.position.set(defaultPosition.x, defaultPosition.y, defaultPosition.z);\r\n        setTimeout(() => {\r\n            gameOver.value = false\r\n        }, 1000);\r\n    }\r\n\r\n    const checkKeysState = () => {\r\n        const collider = objects['collider']\r\n        const delta = 0.1;\r\n        const player = objects['Robot']\r\n        if(player.userData.velocity.y == 0) lastSavePosition.set(player.position.x, player.position.y, player.position.z)\r\n        let speed =  player.userData.speed\r\n        player.userData.velocity.y += delta * gravity;\r\n        player.position.addScaledVector(player.userData.velocity, delta);\r\n        const oneLoop = currentAnimation?.loop == 2200\r\n\r\n        const angle = controls.getAzimuthalAngle();\r\n        const cameraAngle = angle * 180/Math.PI\r\n        const robotRotation = objects['Robot'].rotation.y * 180 / Math.PI\r\n        let robotAngle = robotRotation\r\n\r\n\r\n        if ((testAllKeys(['ShiftLeft']) || testAllButtons([7])) && !oneLoop) {\r\n            speed *= 2;\r\n        }\r\n\r\n        if (testAllKeys(['KeyW'], ['KeyA', 'KeyS', 'KeyD']) || testAllButtons([12], [13,14,15])) {\r\n            tempVector.set(0, 0, -1).applyAxisAngle(upVector, angle);\r\n            player.position.addScaledVector(tempVector, speed * delta);\r\n            robotAngle = 180 + cameraAngle;\r\n        }\r\n\r\n        if (testAllKeys(['KeyA'], ['KeyW', 'KeyS', 'KeyD']) || testAllButtons([14], [12,13,15])) {\r\n            tempVector.set(-1, 0, 0).applyAxisAngle(upVector, angle);\r\n            player.position.addScaledVector(tempVector, speed * delta);\r\n            robotAngle = -90 + cameraAngle;\r\n        }\r\n\r\n        if (testAllKeys(['KeyS'], ['KeyW', 'KeyA', 'KeyD']) || testAllButtons([13], [12,14,15])) {\r\n            tempVector.set(0, 0, 1).applyAxisAngle(upVector, angle);\r\n            player.position.addScaledVector(tempVector,speed * delta);\r\n            robotAngle = 0 + cameraAngle;\r\n        }\r\n\r\n        if (testAllKeys(['KeyD'], ['KeyW', 'KeyA', 'KeyS']) || testAllButtons([15], [12,13,14])) {\r\n            tempVector.set(1, 0, 0).applyAxisAngle(upVector, angle);\r\n            player.position.addScaledVector(tempVector, speed * delta);\r\n            robotAngle = 90 + cameraAngle;\r\n        }\r\n\r\n        if (testAllKeys(['KeyW', 'KeyA']) || testAllButtons([12, 14])) {\r\n            tempVector.set(-1, 0, -1).applyAxisAngle(upVector, angle);\r\n            player.position.addScaledVector(tempVector, speed * delta);\r\n            robotAngle = -135 + cameraAngle;\r\n        }\r\n\r\n        if (testAllKeys(['KeyW', 'KeyD']) || testAllButtons([12, 15])) {\r\n            tempVector.set(1, 0, -1).applyAxisAngle(upVector, angle);\r\n            player.position.addScaledVector(tempVector, speed * delta);\r\n            robotAngle = 135 + cameraAngle;\r\n        }\r\n\r\n        if (testAllKeys(['KeyS', 'KeyA']) || testAllButtons([13, 14])) {\r\n            tempVector.set(-1, 0, 1).applyAxisAngle(upVector, angle);\r\n            player.position.addScaledVector(tempVector, speed * delta);\r\n            robotAngle = -45 + cameraAngle;\r\n        }\r\n\r\n        if (testAllKeys(['KeyS', 'KeyD']) || testAllButtons([13, 15])) {\r\n            tempVector.set(1, 0, 1).applyAxisAngle(upVector, angle);\r\n            player.position.addScaledVector(tempVector, speed * delta);\r\n            robotAngle = 45 + cameraAngle;\r\n        }\r\n        player.rotation.y = robotAngle * (Math.PI / 180);\r\n\r\n        player.updateMatrixWorld();\r\n        const height = 4.5\r\n        const width = 2.35\r\n        const radius = height/2\r\n        const skeletonExtremes = getSkeletonExtremes(objects['Robot'])\r\n        const robotHeight = skeletonExtremes.max.y-skeletonExtremes.min.y // wysokość postaci\r\n        const palyerBbox = new THREE.Box3().setFromObject(objects['Robot']);\r\n        const playerCenter = skeletonExtremes.min.lerp(skeletonExtremes.max, 0.5)\r\n        const segment = new THREE.Line3(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0))\r\n        tempBox.makeEmpty();\r\n        tempMatrix.copy(collider.matrixWorld).invert();\r\n        tempSegment.copy(segment);\r\n\r\n        tempSegment.start.applyMatrix4(player.matrixWorld).applyMatrix4(tempMatrix);\r\n        tempSegment.end.applyMatrix4(player.matrixWorld).applyMatrix4(tempMatrix);\r\n\r\n        tempBox.expandByPoint(tempSegment.start);\r\n        tempBox.expandByPoint(tempSegment.end);\r\n\r\n        // tempBox.min.addScalar(-radius);\r\n        // tempBox.max.addScalar(radius);\r\n        tempBox.min.sub(new THREE.Vector3(width/2, height/2, width/2));\r\n        tempBox.max.sub(new THREE.Vector3(-width/2, -height/2, -width/2));\r\n\r\n        // const tempBoxHelper = new THREE.Box3Helper(tempBox, new THREE.Color(0x0000ff));\r\n        // scene.add(tempBoxHelper);\r\n        // setTimeout(() => {\r\n        //     scene.remove(tempBoxHelper)\r\n        // }, 1000);\r\n\r\n        // const robotPhelper = new THREE.Mesh(new THREE.SphereGeometry( 0.1, 8, 8 ), new THREE.MeshBasicMaterial( {color: 0x00ff00} ));\r\n        // robotPhelper.position.set(player.position.x, player.position.y, player.position.z)\r\n        // scene.add(robotPhelper)\r\n        // setTimeout(() => {\r\n        //     scene.remove(robotPhelper)\r\n        // }, 1000);\r\n\r\n\r\n        // tempVector - najbliższy punkt na siatce (czerwony)\r\n        // tempVector2 - najbliższy punkt na obiekcie (niebieski)\r\n        collider.geometry.boundsTree.shapecast(\r\n            collider,\r\n            box => box.intersectsBox(tempBox), // box - najbliższy bvh z którym zachodzi kolizja\r\n            tri => { // tri - najbliższy trójkąt w bvh z którym zaszła kolizja\r\n                const distance = tri.closestPointToSegment(tempSegment, tempVector, tempVector2);\r\n\r\n                // const tempVectorHelper = new THREE.Mesh(new THREE.SphereGeometry( 0.1, 8, 8 ), new THREE.MeshBasicMaterial( {color: 0xff0000} ));\r\n                // tempVectorHelper.position.set(tempVector.x, tempVector.y, tempVector.z)\r\n                // scene.add(tempVectorHelper)\r\n                // setTimeout(() => {\r\n                //     scene.remove(tempVectorHelper)\r\n                // }, 1000);\r\n\r\n                // const tempVector2Helper = new THREE.Mesh(new THREE.SphereGeometry( 0.1, 8, 8 ), new THREE.MeshBasicMaterial( {color: 0x0000ff} ));\r\n                // tempVector2Helper.position.set(tempVector2.x, tempVector2.y, tempVector2.z)\r\n                // scene.add(tempVector2Helper)\r\n                // setTimeout(() => {\r\n                //     scene.remove(tempVector2Helper)\r\n                // }, 1000);\r\n\r\n\r\n                if (distance < radius) {\r\n                    const depth = radius - distance;\r\n                    const direction = tempVector2.sub(tempVector).normalize(); // normalize - tworzy kierunek z wektora o dowolnej długości\r\n\r\n                    tempSegment.start.addScaledVector(direction, depth);\r\n                    tempSegment.end.addScaledVector(direction, depth);\r\n                }\r\n            }\r\n        );\r\n\r\n        // const tempVectorHelper = new THREE.Mesh(new THREE.SphereGeometry( 0.1, 8, 8 ), new THREE.MeshBasicMaterial( {color: 0xff0000} ));\r\n        // tempVectorHelper.position.set(tempSegment.start.x, tempSegment.start.y, tempSegment.start.z)\r\n        // scene.add(tempVectorHelper)\r\n        // setTimeout(() => {\r\n        //     scene.remove(tempVectorHelper)\r\n        // }, 1000);\r\n\r\n        const newPosition = tempVector;\r\n        newPosition.copy(tempSegment.start).applyMatrix4(collider.matrixWorld);\r\n        const deltaVector = tempVector2;\r\n        deltaVector.subVectors(newPosition, player.position);\r\n\r\n        player.position.copy(newPosition);\r\n\r\n        player.userData.isOnGround = deltaVector.y > Math.abs(delta * player.userData.velocity.y * 0.25);\r\n\r\n        if (!player.userData.isOnGround) {\r\n            deltaVector.normalize();\r\n            player.userData.velocity.addScaledVector(deltaVector, -deltaVector.dot(player.userData.velocity));\r\n        } else {\r\n            player.userData.velocity.set(0, 0, 0);\r\n        }\r\n\r\n        if (player.position.y < -25) {\r\n            player.userData.velocity.set(0, 0, 0);\r\n            player.position.set(lastSavePosition.x, lastSavePosition.y, lastSavePosition.z);\r\n            lifes.value--\r\n            if (lifes.value <= 0) gameOver.value = true\r\n        }\r\n\r\n        // const robotPosition = objects['Robot'].position.clone()\r\n        // const robotRotation = objects['Robot'].rotation.y * 180 / Math.PI\r\n        // const skeletonExtremes = getSkeletonExtremes(objects['Robot'])\r\n        // const robotHeight = skeletonExtremes.max.y-skeletonExtremes.min.y // wysokość postaci\r\n        // const raycasterPosition = robotPosition.clone()\r\n        // raycasterPosition.y += robotHeight;\r\n        // let speed = 0.18;\r\n        //const horizontalOffset = 1; // powinien wynosić promień poziomy postaci\r\n        //const distanceLimitUp = 1.2; // limit wielkości na jaką może wejść (bez skoku)\r\n        //const distanceLimitDown = 5; // limit wielkości z jakiej może zejść\r\n        //let angle = robotRotation;\r\n        //const move = new THREE.Vector3();\r\n        //const oneLoop = currentAnimation?.loop == 2200\r\n        //const axis = testAxis()\r\n        //const cameraAngle = controls.getAzimuthalAngle() * 180/Math.PI\r\n\r\n\r\n        // const robotPositionHelper = new THREE.Mesh(new THREE.SphereGeometry( 0.1, 8, 8 ), new THREE.MeshBasicMaterial( {color: 0xff0000} ));\r\n        // robotPositionHelper.position.set(robotPosition.x, robotPosition.y, robotPosition.z)\r\n        // scene.add(robotPositionHelper)\r\n        // setTimeout(() => {\r\n        //     scene.remove(robotPositionHelper)\r\n        // }, 300);\r\n\r\n        // if ((testAllKeys(['ShiftLeft']) || testAllButtons([7])) && !oneLoop) {\r\n        //     speed *= 2;\r\n        // }\r\n\r\n        // if (testAllKeys(['KeyW'], ['KeyA', 'KeyS', 'KeyD']) || testAllButtons([12], [13,14,15])) {\r\n        //     angle = 180 + cameraAngle;\r\n        // } else if (testAllKeys(['KeyA'], ['KeyW', 'KeyS', 'KeyD']) || testAllButtons([14], [12,13,15])) {\r\n        //     angle = -90 + cameraAngle;\r\n        // } else if (testAllKeys(['KeyS'], ['KeyW', 'KeyA', 'KeyD']) || testAllButtons([13], [12,14,15])) {\r\n        //     angle = 0 + cameraAngle;\r\n        // } else if (testAllKeys(['KeyD'], ['KeyW', 'KeyA', 'KeyS']) || testAllButtons([15], [12,13,14])) {\r\n        //     angle = 90 + cameraAngle;\r\n        // } else if (testAllKeys(['KeyW', 'KeyA']) || testAllButtons([12, 14])) {\r\n        //     angle = -135 + cameraAngle;\r\n        // } else if (testAllKeys(['KeyW', 'KeyD']) || testAllButtons([12, 15])) {\r\n        //     angle = 135 + cameraAngle;\r\n        // } else if (testAllKeys(['KeyS', 'KeyA']) || testAllButtons([13, 14])) {\r\n        //     angle = -45 + cameraAngle;\r\n        // } else if (testAllKeys(['KeyS', 'KeyD']) || testAllButtons([13, 15])) {\r\n        //     angle = 45 + cameraAngle;\r\n        // }\r\n\r\n        // if (testAnyKeys(['KeyW', 'KeyA', 'KeyS', 'KeyD']) || testAnyButton([12,13,14,15]) || testAxis()) {\r\n        //     move.x = getCoordsFromAngle(angle).x * speed;\r\n        //     move.z = getCoordsFromAngle(angle).z * speed;\r\n        //     raycasterPosition.x += getCoordsFromAngle(angle).x * speed + horizontalOffset;\r\n        //     raycasterPosition.z += getCoordsFromAngle(angle).z * speed + horizontalOffset;\r\n        // }\r\n\r\n        // if(axis) {\r\n        //     angle = axis.angle + cameraAngle\r\n        //     move.x = axis.x * speed\r\n        //     move.z = axis.z * speed\r\n        //     raycasterPosition.x += axis.x * speed + (axis.x > 0? horizontalOffset : -horizontalOffset);\r\n        //     raycasterPosition.z += axis.z * speed + (axis.z > 0? horizontalOffset : -horizontalOffset);\r\n        // }\r\n\r\n        updateCameraPosition()\r\n        // const rotationRange = Math.abs(robotRotation - angle)\r\n        // if(oneLoop && rotationRange > 45 && rotationRange < 315) {\r\n        //     angle = robotRotation\r\n        //     move.x = 0\r\n        //     move.z = 0\r\n        // }\r\n\r\n        // Wykrywanie kolizji\r\n        // raycaster.set(raycasterPosition, new THREE.Vector3(0, -1, 0));\r\n        // const intersects = raycaster.intersectObject(objects['floor'], true);\r\n\r\n        // Pokazuje promienie raycastera\r\n        // const raycasterHelper = new THREE.ArrowHelper(raycaster.ray.direction, raycaster.ray.origin, robotHeight, 0xff00ff)\r\n        // scene.add(raycasterHelper);\r\n        // setTimeout(() => {scene.remove(raycasterHelper)}, 3000);\r\n\r\n        // Odległość od raycastera do najniższej części robota\r\n        //const rayToRobotDistance = Math.abs(skeletonExtremes.min.y - robotPosition.y)\r\n        // const rayToRobotDistanceHelper = new THREE.ArrowHelper(new Vector3(0, 1, 0), robotPosition, rayToRobotDistance, 0xff0000, 0, 0)\r\n        // rayToRobotDistanceHelper.renderOrder = 9999\r\n        // scene.add(rayToRobotDistanceHelper)\r\n        // setTimeout(() => {\r\n        //     scene.remove(rayToRobotDistanceHelper)\r\n        // }, 3000);\r\n\r\n        // Odległość od kolizji do pozycji Robota\r\n        //const collistionToRobotTop = intersects[0] ? intersects[0].distance - robotHeight : 0\r\n\r\n        // Sprawdza czy poruszamy sie w dół czy do góry\r\n        //const goUp = collistionToRobotTop >= 0 ? false : true\r\n\r\n        // if(intersects[0]) {\r\n        //     const collistionToRobotTopPosition = intersects[0].point.clone()\r\n        //     collistionToRobotTopPosition.x += 0.01\r\n        //     collistionToRobotTopPosition.z += 0.01\r\n        //     const collistionToRobotTopHelper = new THREE.ArrowHelper(new Vector3(0, goUp? -1 : 1, 0), collistionToRobotTopPosition, Math.abs(collistionToRobotTop), 0xffff00, 0, 0)\r\n        //     collistionToRobotTopHelper.renderOrder = 99999\r\n        //     scene.add(collistionToRobotTopHelper)\r\n        //     setTimeout(() => {\r\n        //         scene.remove(collistionToRobotTopHelper)\r\n        //     }, 3000);\r\n        // }\r\n\r\n        // if (intersects[0] && Math.abs(collistionToRobotTop) < distanceLimitUp + rayToRobotDistance && goUp) {\r\n        //     if(oneLoop) {\r\n        //         if(rayToRobotDistance >= Math.abs(collistionToRobotTop)) {\r\n        //             move.y = 0\r\n        //         } else {\r\n        //             if (oneLoopTrigger < Math.abs(collistionToRobotTop + rayToRobotDistance)) {\r\n        //                 move.y = Math.abs(collistionToRobotTop + rayToRobotDistance)\r\n        //                 if(currentAnimation) currentAnimation.warp(currentAnimation.timeScale, currentAnimation.timeScale*4, currentAnimation.getClip().duration-currentAnimation.time)\r\n        //             } else {\r\n        //                 move.y = 0\r\n        //             }\r\n        //         }\r\n\r\n        //         oneLoopTrigger = Math.abs(collistionToRobotTop + rayToRobotDistance)\r\n        //         return { move, angle };\r\n        //     } else {\r\n        //         oneLoopTrigger = 0\r\n        //         move.y = -intersects[0].distance + robotHeight;\r\n        //         return { move, angle };\r\n        //     }\r\n        // } else if(intersects[0] && collistionToRobotTop < distanceLimitDown && !goUp) {\r\n        //     move.y = -intersects[0].distance + robotHeight;\r\n        //     return { move, angle };\r\n        // } else {\r\n        //     move.x = 0;\r\n        //     move.y = 0;\r\n        //     move.z = 0;\r\n        //     return { move, angle};\r\n        // }\r\n    }\r\n\r\n    const robotRunning = () => {\r\n        if (mixers['Robot']) {\r\n            if (testAnyKeys(['KeyW', 'KeyA', 'KeyS', 'KeyD']) || testAnyButton([12,13,14,15]) || testAxis()) {\r\n                let acceleration = 1;\r\n                if (testAllKeys(['ShiftLeft']) || testAllButtons([7])) {\r\n                    acceleration = 2;\r\n                }\r\n                playAnimation(mixers['Robot'], animations['Robot'], 'Robot_Running', acceleration);\r\n            } else {\r\n                stopAnimation(mixers['Robot'], animations['Robot'], 'Robot_Running');\r\n            }\r\n\r\n            if (testAnyKeys(['Space']) || testAllButtons([0])) {\r\n                if(!pauseOthersAnimations) {\r\n                    //playAnimation(mixers['Robot'], animations['Robot'], 'Robot_Jump', 0.6, false);\r\n                    if(objects['Robot'].userData.velocity.y == 0) objects['Robot'].userData.velocity.y = 5;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    const toAnimate = () => {\r\n        for (const model in mixers) {\r\n            mixers[model].update(clock.getDelta());\r\n        }\r\n        if(objects['Robot'] && objects['collider']) checkKeysState()\r\n\r\n        // Jeżeli którykolwiek klawisz jest wciśnięty\r\n        if (Object.values(pressedKeys).includes(true) || pauseOthersAnimations || gamepads.value[0]) {\r\n            const keysStateResult = checkKeysState();\r\n            //objects['Robot'].position.add(keysStateResult.move);\r\n            //objects['Robot'].rotation.y = keysStateResult.angle * (Math.PI / 180);\r\n        }\r\n    }\r\n\r\n    const getSkeletonExtremes = (object: THREE.Object3D) => {\r\n        const skeleton = new THREE.SkeletonHelper(object)\r\n        const bone_min = new THREE.Vector3(Infinity,Infinity, Infinity);\r\n        const bone_max = new THREE.Vector3(-Infinity,-Infinity,-Infinity);\r\n\r\n        for(let b=0; b < skeleton.bones.length; b++){\r\n            const child = skeleton.bones[b];\r\n            const position = new THREE.Vector3();\r\n            child.getWorldPosition(position);\r\n\r\n            if(position.x < bone_min.x) bone_min.x = position.x\r\n            if(position.y < bone_min.y) bone_min.y = position.y\r\n            if(position.z < bone_min.z) bone_min.z = position.z\r\n\r\n            if(position.x > bone_max.x) bone_max.x = position.x\r\n            if(position.y > bone_max.y) bone_max.y = position.y\r\n            if(position.z > bone_max.z) bone_max.z = position.z\r\n        }\r\n\r\n        return {min: bone_min, max: bone_max}\r\n    }\r\n\r\n    onMounted( () => {\r\n        loader.load(\r\n            characterPath,\r\n            gltf => {\r\n                const model = gltf.scene;\r\n                model.traverse(child => {\r\n                    if (child instanceof THREE.Mesh) {\r\n                        child.castShadow = true;\r\n                        child.receiveShadow = true;\r\n                        child.material.shadowSide = 2;\r\n                    }\r\n                });\r\n\r\n                model.userData.name = 'Robot';\r\n                model.userData.isOnGround = false;\r\n                model.userData.velocity = new THREE.Vector3(0, 0, 0);\r\n                model.userData.speed = 1.5,\r\n                model.position.set(position.x, position.y, position.z);\r\n                scene.add(model);\r\n\r\n                //Zapisz dane obiektu\r\n                objects[model.userData.name] = model; // Obiekt\r\n                animations[model.userData.name] = gltf.animations; // Animacja\r\n                mixers[model.userData.name] = new THREE.AnimationMixer(model); // Mikser animacji\r\n                mixers[model.userData.name].addEventListener('finished', function(e: any) {\r\n                    pauseOthersAnimations = false;\r\n                    robotRunning()\r\n                    //console.log('animacja '+ e.action._clip.name +' skonczona');\r\n                });\r\n                animations[model.userData.name].forEach((animation: THREE.AnimationClip) => {\r\n                    mixers[model.userData.name].clipAction(animation).setEffectiveWeight(0).play()\r\n                });\r\n            },\r\n            undefined,\r\n            function(error) {\r\n                console.error(error);\r\n            },\r\n        );\r\n    });\r\n\r\n    return {\r\n        robotRunning,\r\n        toAnimate,\r\n        lifes,\r\n        resetGame\r\n    }\r\n}","import { onUnmounted, ref, Ref } from 'vue';\r\n\r\nexport default function keysControls(pressedKeys: any) {\r\n\r\n    const keysFunctions: Array<any> = [];\r\n    const gamepads: Ref<(Gamepad | null)[]> = ref([]);\r\n\r\n    const keyUp = (e: any) => {\r\n        pressedKeys[e.code] = false;\r\n    }\r\n\r\n    const keyDown = (e: any) => {\r\n        pressedKeys[e.code] = true;\r\n    }\r\n\r\n    const connectGamepad = (e: any) => {\r\n        console.log(e.gamepad.id, 'podłączony')\r\n    }\r\n\r\n    const disconectGamepad = (e: any) => {\r\n        console.log(e.gamepad.id, 'odłączony')\r\n    }\r\n\r\n    const checkPads = () => {\r\n        gamepads.value = navigator.getGamepads()\r\n    }\r\n\r\n    const checkPressedKeys = () => {\r\n        keysFunctions.forEach(func => { func() });\r\n    }\r\n\r\n    window.addEventListener('keydown', keyDown);\r\n    window.addEventListener('keyup', keyUp);\r\n    window.addEventListener(\"gamepadconnected\", connectGamepad);\r\n    window.addEventListener(\"gamepaddisconnected\", disconectGamepad)\r\n\r\n    const testAllKeys = (keysArray: any, exceptionKeysArray: any = null) => {\r\n        const activeInArray = keysArray.every((e: any) => pressedKeys[e] === true); // Czy klawisze z listy są wciąnięte\r\n        if (exceptionKeysArray) {\r\n            const exceptionInArray = exceptionKeysArray.every((e: any) => pressedKeys[e] === false || pressedKeys[e] === undefined);\r\n            return activeInArray && exceptionInArray;\r\n        }\r\n        return activeInArray;\r\n    };\r\n\r\n    const testAnyKeys = (keysArray: any) => {\r\n        return keysArray.some((e: any) => pressedKeys[e] === true);\r\n    };\r\n\r\n    const testAllButtons = (buttonsArray: any, exceptionKeysArray: any = null) => {\r\n        const activeInArray = buttonsArray.every((button: any) => gamepads.value[0]?.buttons[button].pressed)\r\n        if (exceptionKeysArray) {\r\n            const exceptionInArray = exceptionKeysArray.every((button: any) => !gamepads.value[0]?.buttons[button].pressed);\r\n            return activeInArray && exceptionInArray;\r\n        }\r\n        return activeInArray;\r\n    }\r\n\r\n    const testAxis = () => {\r\n        if(gamepads.value[0]) {\r\n            const axisTolerance = 0.3\r\n            const a0 = gamepads.value[0]?.axes[0] \r\n            const a1 = gamepads.value[0]?.axes[1]\r\n            const angle = Math.atan2(a1, -a0) * 180 / Math.PI;\r\n\r\n            const result = {\r\n                angle: angle - 90,\r\n                x: a0,\r\n                z: a1\r\n            }\r\n\r\n            if(Math.abs(a0) > axisTolerance || Math.abs(a1) > axisTolerance) return result\r\n        }\r\n    }\r\n\r\n    const testAnyButton = (buttonsArray: any) => {\r\n        return buttonsArray.some((button: any) => gamepads.value[0]?.buttons[button].pressed);\r\n    };\r\n\r\n    onUnmounted(() => {\r\n        window.removeEventListener('keydown', keyDown);\r\n        window.removeEventListener('keyup', keyUp);\r\n        window.removeEventListener(\"gamepadconnected\", connectGamepad);\r\n        window.addEventListener(\"gamepaddisconnected\", disconectGamepad)\r\n    })\r\n\r\n    return {\r\n        testAllKeys,\r\n        testAnyKeys,\r\n        keysFunctions,\r\n        checkPressedKeys,\r\n        testAllButtons,\r\n        testAnyButton,\r\n        testAxis,\r\n        checkPads,\r\n        gamepads\r\n    }\r\n}\r\n","import { onMounted, reactive } from 'vue';\r\nimport * as THREE from 'three';\r\n\r\n\r\nexport default function addLoaderManager(manager: THREE.LoadingManager) {\r\n    const loading = reactive({\r\n        loaded: 0,\r\n        total: 0,\r\n        progress: 0,\r\n    })\r\n\r\n    onMounted( () => {\r\n        manager.onProgress = (item, loaded, total) => {\r\n            loading.loaded = loaded;\r\n            loading.total = total;\r\n            loading.progress = Math.round((loaded / total) * 10000) / 100;\r\n        };\r\n    })\r\n\r\n    return {\r\n        loading\r\n    };\r\n}","\r\nimport * as THREE from 'three';\r\nimport createScene from '../hooks/createScene';\r\nimport addLights from '../hooks/addLights';\r\nimport postProduction from '../hooks/postProduction';\r\nimport addMap from '../hooks/addMap';\r\nimport addCharacter from '../hooks/addCharacter';\r\nimport keysControls from '../hooks/keysControls';\r\nimport addLoaderManager from '../hooks/addLoaderManager';\r\nimport { publicPath } from '../../vue.config';\r\n\r\nimport { ref } from 'vue';\r\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\r\nimport { Vector3 } from 'three';\r\n\r\nimport * as dat from 'dat.gui';\r\n\r\nexport default {\r\n    setup() {\r\n        const popup = ref(false);\r\n        const gameOver = ref(false)\r\n\r\n        // Zmienne sceny\r\n        const characterPosition = new Vector3(0, 0, 0);\r\n        const cameraOffset = new Vector3(2.5, 15, 25);\r\n\r\n        // Dodaj scenę\r\n        const sceneRef = ref(null);\r\n        const { scene, renderer, camera, animateFunctions, animation, controls, scaleFactor, onWindowResize } = createScene(sceneRef, characterPosition, cameraOffset);\r\n\r\n        // Dodaj światła\r\n        addLights(scene);\r\n\r\n        // Dodaj postprodukcję\r\n        postProduction(scene, camera, renderer)\r\n\r\n        // Dodaj manager ładowania\r\n        const manager = new THREE.LoadingManager();\r\n        const { loading } = addLoaderManager(manager)\r\n        // let shadowTick = true\r\n        // animateFunctions.push(() => {\r\n        //     if(loading.progress == 100 && shadowTick == true) {\r\n        //         renderer.shadowMap.needsUpdate = true\r\n        //         shadowTick = false\r\n        //     }\r\n        // })\r\n\r\n        // Załaduj główną mapę\r\n        const loader = new GLTFLoader(manager);\r\n        const objects: any = {};\r\n        addMap(loader, scene, objects, `${publicPath}islands/islands.gltf`, `${publicPath}islands/islands_physics.gltf`);\r\n\r\n        // Wczytaj funkcje obsługi klawiszy i padów\r\n        const pressedKeys: any = {};\r\n\r\n        const { testAllKeys, testAnyKeys, keysFunctions, checkPressedKeys, testAllButtons, testAnyButton, testAxis, checkPads, gamepads} = keysControls(pressedKeys);\r\n        animateFunctions.push(checkPressedKeys, checkPads)\r\n\r\n        // Wczytaj postać z funkcjami ruchu i animacji\r\n        const animations: any = {};\r\n        const mixers: any = {};\r\n        const { robotRunning, toAnimate, lifes, resetGame } = addCharacter(\r\n            loader, scene, objects, animations, mixers,\r\n            pressedKeys, testAllKeys, testAnyKeys,\r\n            gamepads, testAllButtons, testAnyButton, testAxis, `${publicPath}Robot_edited_centered.glb`,\r\n            controls, camera, characterPosition, cameraOffset, animation, gameOver\r\n        );\r\n        animateFunctions.push(toAnimate);\r\n        keysFunctions.push(robotRunning);\r\n\r\n        const guiTemp = {\r\n            reset: () => {resetGame()}\r\n        }\r\n\r\n        const gui = new dat.GUI();\r\n        const optimization = gui.addFolder('Optymalizacja')\r\n        optimization.open()\r\n        optimization.add(scaleFactor, 'value', 0, 1).name('Scale Factor').onChange(onWindowResize);\r\n        optimization.add(renderer.shadowMap, 'autoUpdate').name('Update shadows')\r\n        optimization.add(camera, 'far', 60, 500, 10).name('Draw distance').setValue(300).onChange(() => {\r\n            (scene.fog as any).far = camera.far;\r\n            (scene.fog as any).near = camera.far/3\r\n            camera.updateProjectionMatrix()\r\n        })\r\n        gui.add(popup, 'value').name('Pokaż sterowanie');\r\n        gui.add(guiTemp, 'reset').name('Reset position');\r\n\r\n        return {\r\n            sceneRef,\r\n            loading,\r\n            popup,\r\n            close,\r\n            camera,\r\n            animations,\r\n            mixers,\r\n            lifes,\r\n            gameOver,\r\n            resetGame\r\n        }\r\n    }\r\n}\r\n","import { render } from \"./NewScene.vue?vue&type=template&id=d8b5e8e2&scoped=true\"\nimport script from \"./NewScene.vue?vue&type=script&lang=ts\"\nexport * from \"./NewScene.vue?vue&type=script&lang=ts\"\n\nimport \"./NewScene.vue?vue&type=style&index=0&id=d8b5e8e2&scoped=true&lang=scss\"\nscript.render = render\nscript.__scopeId = \"data-v-d8b5e8e2\"\n\nexport default script","\r\nimport { Options, Vue } from 'vue-class-component';\r\nimport Scene from '../components/Scene.vue';\r\nimport NewScene from '../components/NewScene.vue';\r\n\r\n@Options({\r\n    components: {\r\n        Scene, NewScene\r\n    },\r\n})\r\nexport default class App extends Vue {}\r\n","import { render } from \"./Home.vue?vue&type=template&id=c1e5622a\"\nimport script from \"./Home.vue?vue&type=script&lang=ts\"\nexport * from \"./Home.vue?vue&type=script&lang=ts\"\nscript.render = render\n\nexport default script","import { createRouter, createWebHistory, RouteRecordRaw } from 'vue-router'\nimport Home from '../views/Home.vue'\n\nconst routes: Array<RouteRecordRaw> = [\n    {\n        path: '/',\n        name: 'Home',\n        component: Home\n    }\n]\n\nconst router = createRouter({\n    history: createWebHistory(process.env.BASE_URL),\n    routes\n})\n\nexport default router\n","import { createStore } from 'vuex'\n\nexport default createStore({\n    state: {\n    },\n    mutations: {\n    },\n    actions: {\n    },\n    modules: {\n    }\n})\n","import { createApp } from 'vue'\r\nimport App from './App.vue'\r\nimport router from './router'\r\nimport store from './store'\r\n\r\ncreateApp(App).use(store).use(router).mount('#app')\r\n"],"sourceRoot":""}