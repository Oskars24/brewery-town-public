{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/components/Scene.vue?7a67","webpack:///./vue.config.js","webpack:///./src/App.vue?2e49","webpack:///./src/App.vue","webpack:///./src/App.vue?dfb6","webpack:///./src/views/Home.vue","webpack:///./src/components/Scene.vue","webpack:///./src/components/Scene.vue?87b2","webpack:///./src/components/Scene.vue?53da","webpack:///./src/components/NewScene.vue","webpack:///./src/hooks/createScene.ts","webpack:///./src/hooks/addLights.ts","webpack:///./src/hooks/postProduction.ts","webpack:///./src/hooks/addMap.ts","webpack:///./src/hooks/addCharacter.ts","webpack:///./src/hooks/keysControls.ts","webpack:///./src/hooks/addLoaderManager.ts","webpack:///./src/components/NewScene.vue?7ae4","webpack:///./src/components/NewScene.vue?4af3","webpack:///./src/views/Home.vue?d5e7","webpack:///./src/views/Home.vue?ab8c","webpack:///./src/router/index.ts","webpack:///./src/store/index.ts","webpack:///./src/main.ts","webpack:///./src/components/NewScene.vue?5c59"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","publicPath","id","script","render","class","ref","setup","camera","renderer","antialias","scene","clock","raycaster","objects","mixers","animations","pressedKeys","sceneRef","playAnimation","objectMixer","objectAnimations","animationName","acceleration","loop","weight","clip","find","el","animation","clipAction","timeScale","isPlaying","setTimeout","duration","setEffectiveWeight","play","setLoop","reset","setEffectiveTimeScale","stopAnimation","stop","testAllKeys","keysArray","exceptionKeysArray","activeInArray","every","e","exceptionInArray","undefined","testAnyKeys","some","checkKeysState","robotPosition","position","x","y","z","positionOffset","speed","distanceLimit","angle","move","set","intersects","intersectObject","distance","robotRunning","keyUp","code","keyDown","addEventListener","mixer","clientWidth","clientHeight","setSize","appendChild","domElement","loader","GLTFLoader","load","gltf","model","add","error","console","userData","forEach","action","_clip","log","visible","ambientLight","mainLight","controls","OrbitControls","enableDamping","dampingFactor","screenSpacePanning","minDistance","maxDistance","composer","EffectComposer","renderPass","RenderPass","addPass","pass","SMAAPass","innerWidth","getPixelRatio","innerHeight","animate","requestAnimationFrame","update","getDelta","values","includes","keysStateResult","rotation","Math","PI","removeEventListener","__scopeId","loading","loaded","total","progress","popup","createScene","characterPosition","cameraOffset","animateFunctions","scaleFactor","maxClientWidth","maxClientHeight","onWindowResize","aspect","updateProjectionMatrix","setPixelRatio","min","devicePixelRatio","fov","near","far","shadowMap","enabled","type","background","fog","stats","showPanel","document","body","dom","maxPolarAngle","enablePan","enableZoom","target","begin","func","end","addLights","multiplyScalar","shadow","mapSize","setScalar","bias","normalBias","castShadow","shadowCam","bottom","left","top","right","postProduction","addMap","mapPath","collisionMapPath","box","setFromObject","getCenter","negate","updateMatrixWorld","toMerge","traverse","child","hex","material","color","getHex","receiveShadow","shadowSide","environment","arr","visualGeometries","mesh","emissive","attach","geom","geometry","clone","applyMatrix4","matrixWorld","newGeom","BufferGeometryUtils","mergeBufferGeometries","newMesh","opacity","transparent","depthWrite","geometries","cloned","attributes","deleteAttribute","mergedGeometry","boundsTree","lazyGeneration","collider","wireframe","visualizer","addCharacter","gamepads","testAllButtons","testAnyButton","testAxis","characterPath","pauseOthersAnimations","tempBox","tempMatrix","tempSegment","tempVector","tempVector2","upVector","gravity","currentAnimation","time","getClip","fadeOut","getFadeTime","fadeIn","startAnimation","endAnimation","startAnimationTime","getEffectiveTimeScale","endAnimationTime","updateCameraPosition","targets","easing","complete","delta","player","velocity","addScaledVector","oneLoop","getAzimuthalAngle","cameraAngle","robotRotation","robotAngle","applyAxisAngle","height","width","radius","skeletonExtremes","getSkeletonExtremes","segment","max","lerp","makeEmpty","copy","invert","start","expandByPoint","sub","shapecast","intersectsBox","tri","closestPointToSegment","depth","direction","normalize","newPosition","deltaVector","subVectors","isOnGround","abs","dot","toAnimate","skeleton","bone_min","Infinity","bone_max","b","bones","getWorldPosition","keysControls","keysFunctions","connectGamepad","gamepad","disconectGamepad","checkPads","navigator","getGamepads","checkPressedKeys","buttonsArray","button","buttons","pressed","axisTolerance","a0","axes","a1","atan2","addLoaderManager","manager","onProgress","item","round","close","components","Scene","NewScene","routes","path","component","Home","router","history","state","mutations","actions","use","store","mount"],"mappings":"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","file":"js/app.41c33c0c.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t\"app\": 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/brewery-town-public/\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([0,\"chunk-vendors\"]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader-v16/dist/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader-v16/dist/index.js??ref--0-1!./Scene.vue?vue&type=style&index=0&id=549912f1&scoped=true&lang=scss\"","module.exports = {\r\n    publicPath: process.env.NODE_ENV === 'production' ? '/brewery-town-public/' : '/',\r\n};\r\n\r\n","export * from \"-!../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../node_modules/vue-loader-v16/dist/stylePostLoader.js!../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader-v16/dist/index.js??ref--0-1!./App.vue?vue&type=style&index=0&id=04222ae9&lang=scss\"","<template>\n    <div id=\"app\">\n        <router-view />\n    </div>\n</template>\n\n<style lang=\"scss\">\nbody {\n    margin: 0;\n    background: black\n}\n</style>\n","import { render } from \"./App.vue?vue&type=template&id=04222ae9\"\nconst script = {}\n\nimport \"./App.vue?vue&type=style&index=0&id=04222ae9&lang=scss\"\nscript.render = render\n\nexport default script","<template>\r\n    <div>\r\n        <!-- <Scene /> -->\r\n        <new-scene/>\r\n    </div>\r\n</template>\r\n\r\n<script lang=\"ts\">\r\nimport { Options, Vue } from 'vue-class-component';\r\nimport Scene from '../components/Scene.vue';\r\nimport NewScene from '../components/NewScene.vue';\r\n\r\n@Options({\r\n    components: {\r\n        Scene, NewScene\r\n    },\r\n})\r\nexport default class App extends Vue {}\r\n</script>\r\n","<template v-cloak>\r\n    <div class=\"container\">\r\n        <div class=\"scene\" ref=\"sceneRef\"></div>\r\n    </div>\r\n</template>\r\n\r\n<script lang=\"ts\">\r\n//import { Options, Vue } from 'vue-class-component';\r\nimport * as THREE from 'three';\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\r\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\r\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';\r\nimport { SMAAPass } from 'three/examples/jsm/postprocessing/SMAAPass.js';\r\n\r\nimport { ref, onMounted, onUnmounted } from 'vue'\r\n\r\nexport default {\r\n    setup() {\r\n        let camera!: THREE.PerspectiveCamera\r\n        const renderer: THREE.WebGLRenderer = new THREE.WebGLRenderer({ antialias: true });\r\n        const scene: THREE.Scene = new THREE.Scene();\r\n        const clock = new THREE.Clock();\r\n        const raycaster = new THREE.Raycaster();\r\n        const objects: any = {};\r\n        const mixers: any = {};\r\n        const animations: any = {};\r\n        const pressedKeys: any = {};\r\n        const sceneRef = ref(null);\r\n\r\n        const playAnimation = (objectMixer: any, objectAnimations: any, animationName: any, acceleration = 1, loop = true, weight = 1) => {\r\n            const clip = objectAnimations.find((el: any) => el.name === animationName);\r\n            const animation = objectMixer.clipAction(clip);\r\n            animation.timeScale = acceleration;\r\n            if (animations['Robot'][2].isPlaying) {\r\n                weight = 0;\r\n                setTimeout(() => {\r\n                    playAnimation(objectMixer, objectAnimations, animationName, acceleration, true, 1);\r\n                }, animations['Robot'][2].duration * 1000);\r\n            }\r\n            clip.isPlaying = true;\r\n            if (!loop) {\r\n                animation.setLoop(THREE.LoopOnce);\r\n                animation\r\n                    .reset()\r\n                    .setEffectiveTimeScale(0.5)\r\n                    .setEffectiveWeight(1) // wykombinować to ustawienie dla wszystkich animacji łączonych\r\n                    .play();\r\n            } else {\r\n                animation.setEffectiveWeight(weight).play();\r\n            }\r\n        }\r\n\r\n        const stopAnimation = (objectMixer: any, objectAnimations: any, animationName: any) => {\r\n            const clip = objectAnimations.find((el: any) => el.name === animationName);\r\n            const animation = objectMixer.clipAction(clip);\r\n            animation.stop();\r\n        }\r\n\r\n        const testAllKeys = (keysArray: any, exceptionKeysArray: any = null) => {\r\n            const activeInArray = keysArray.every((e: any) => pressedKeys[e] === true); // Czy klawisze z listy są wciąnięte\r\n            if (exceptionKeysArray) {\r\n                const exceptionInArray = exceptionKeysArray.every((e: any) => pressedKeys[e] === false || pressedKeys[e] === undefined);\r\n                return activeInArray && exceptionInArray;\r\n            }\r\n            return activeInArray;\r\n        };\r\n\r\n        const testAnyKeys = (keysArray: any) => {\r\n            return keysArray.some((e: any) => pressedKeys[e] === true);\r\n        };\r\n\r\n        const checkKeysState = () => {\r\n            const robotPosition = new THREE.Vector3(objects['Robot'].position.x, objects['Robot'].position.y, objects['Robot'].position.z);\r\n            const positionOffset = 5; // największa wysokość na jaką może wejść\r\n            robotPosition.y += positionOffset;\r\n            let speed = 0.18;\r\n            const distanceLimit = 6; // limit wielkości na jaką może wejść/zejść\r\n            let angle = 0;\r\n            const move = new THREE.Vector3();\r\n\r\n            if (testAllKeys(['ShiftLeft'])) {\r\n                speed *= 2;\r\n            }\r\n\r\n            if (testAllKeys(['KeyW'], ['KeyA', 'KeyS', 'KeyD'])) {\r\n                angle = 180;\r\n                move.z = -1 * speed;\r\n                robotPosition.z += -1 * speed;\r\n            } else if (testAllKeys(['KeyA'], ['KeyW', 'KeyS', 'KeyD'])) {\r\n                angle = -90;\r\n                move.x = -1 * speed;\r\n                robotPosition.x += -1 * speed;\r\n            } else if (testAllKeys(['KeyS'], ['KeyW', 'KeyA', 'KeyD'])) {\r\n                angle = 0;\r\n                move.z = 1 * speed;\r\n                robotPosition.z += 1 * speed;\r\n            } else if (testAllKeys(['KeyD'], ['KeyW', 'KeyA', 'KeyS'])) {\r\n                angle = 90;\r\n                move.x = 1 * speed;\r\n                robotPosition.x += 1 * speed;\r\n            } else if (testAllKeys(['KeyW', 'KeyA'])) {\r\n                angle = -135;\r\n                move.x = -1 * speed;\r\n                move.z = -1 * speed;\r\n                robotPosition.x += -1 * speed;\r\n                robotPosition.z += -1 * speed;\r\n            } else if (testAllKeys(['KeyW', 'KeyD'])) {\r\n                angle = 135;\r\n                move.x = 1 * speed;\r\n                move.z = -1 * speed;\r\n                robotPosition.x += 1 * speed;\r\n                robotPosition.z += -1 * speed;\r\n            } else if (testAllKeys(['KeyS', 'KeyA'])) {\r\n                angle = -45;\r\n                move.x = -1 * speed;\r\n                move.z = 1 * speed;\r\n                robotPosition.x += -1 * speed;\r\n                robotPosition.z += 1 * speed;\r\n            } else if (testAllKeys(['KeyS', 'KeyD'])) {\r\n                angle = 45;\r\n                move.x = 1 * speed;\r\n                move.z = 1 * speed;\r\n                robotPosition.x += 1 * speed;\r\n                robotPosition.z += 1 * speed;\r\n            }\r\n\r\n            // Wykrywanie kolizji\r\n            raycaster.set(robotPosition, new THREE.Vector3(0, -1, 0));\r\n            const intersects = raycaster.intersectObject(objects['floor'], true);\r\n\r\n            // Pokazuje promienie raycastera\r\n            //this.scene.add(new THREE.ArrowHelper(this.raycaster.ray.direction, this.raycaster.ray.origin, positionOffset, 0xff0000));\r\n\r\n            if (intersects[0] && intersects[0].distance - positionOffset < distanceLimit) {\r\n                move.y = -intersects[0].distance + positionOffset;\r\n                return { move, angle };\r\n            } else {\r\n                move.x = 0;\r\n                move.y = 0;\r\n                move.z = 0;\r\n                return { move, angle };\r\n            }\r\n        }\r\n\r\n        const robotRunning = () => {\r\n            if (mixers['Robot']) {\r\n                if (testAnyKeys(['KeyW', 'KeyA', 'KeyS', 'KeyD'])) {\r\n                    let acceleration = 1;\r\n                    if (testAllKeys(['ShiftLeft'])) {\r\n                        acceleration = 2;\r\n                    }\r\n                    playAnimation(mixers['Robot'], animations['Robot'], 'Robot_Running', acceleration);\r\n                } else {\r\n                    stopAnimation(mixers['Robot'], animations['Robot'], 'Robot_Running');\r\n                }\r\n\r\n                if (testAnyKeys(['Space'])) {\r\n                    playAnimation(mixers['Robot'], animations['Robot'], 'Robot_Jump', 1, false);\r\n                }\r\n            }\r\n        }\r\n\r\n        const keyUp = (e: any) => {\r\n            pressedKeys[e.code] = false;\r\n            robotRunning();\r\n        }\r\n\r\n        const keyDown = (e: any) => {\r\n            pressedKeys[e.code] = true;\r\n            robotRunning();\r\n        }\r\n\r\n        //Created\r\n        window.addEventListener('keydown', keyDown);\r\n        window.addEventListener('keyup', keyUp);\r\n\r\n        onMounted(() => {\r\n            const el = sceneRef.value as any;\r\n            camera = new THREE.PerspectiveCamera(60, el.clientWidth / el.clientHeight, 1, 1000);\r\n            camera.position.set(55, 55, 55);\r\n            renderer.setSize(el.clientWidth, el.clientHeight);\r\n            el.appendChild(renderer.domElement);\r\n\r\n            // Dodanie loadera plików\r\n            let mixer: any;\r\n            const loader = new GLTFLoader();\r\n\r\n            loader.load(\r\n                '/peach_castle/scene.gltf',\r\n                gltf => {\r\n                    const model = gltf.scene;\r\n                    scene.add(model);\r\n\r\n                    //Animacja\r\n                    if (gltf.animations.length) {\r\n                        mixer = new THREE.AnimationMixer(model);\r\n                        mixer.clipAction(gltf.animations[0]).play();\r\n                    }\r\n                },\r\n                undefined,\r\n                function(error) {\r\n                    console.error(error);\r\n                },\r\n            );\r\n\r\n            loader.load(\r\n                '/Robot.gltf',\r\n                gltf => {\r\n                    const model = gltf.scene;\r\n                    model.userData.name = 'Robot';\r\n                    scene.add(model);\r\n                    model.position.set(5, 12, 0);\r\n\r\n                    //Zapisz dane obiektu\r\n                    objects[model.userData.name] = model; // Obiekt\r\n                    animations[model.userData.name] = gltf.animations; // Animacja\r\n                    animations[model.userData.name].forEach((e: any) => {\r\n                        e.isPlaying = false;\r\n                    });\r\n                    mixers[model.userData.name] = new THREE.AnimationMixer(model); // Mikser animacji\r\n                    mixers[model.userData.name].addEventListener('finished', function(e: any) {\r\n                        e.action._clip.isPlaying = false;\r\n                        console.log('animacja skonczona');\r\n                    });\r\n                },\r\n                undefined,\r\n                function(error) {\r\n                    console.error(error);\r\n                },\r\n            );\r\n\r\n            loader.load(\r\n                '/peach_castle/floor.gltf',\r\n                gltf => {\r\n                    const model = gltf.scene;\r\n                    model.userData.name = 'floor';\r\n                    model.visible = false;\r\n                    scene.add(model);\r\n\r\n                    //Zapisz dane obiektu\r\n                    objects[model.userData.name] = model; // Obiekt\r\n                },\r\n                undefined,\r\n                function(error) {\r\n                    console.error(error);\r\n                },\r\n            );\r\n\r\n            // Dodanie światła\r\n            const ambientLight = new THREE.HemisphereLight(0xffffff, 0x222222, 1);\r\n            const mainLight = new THREE.DirectionalLight(0xffffff, 4.0);\r\n            mainLight.position.set(10, 10, 10);\r\n            scene.add(ambientLight, mainLight);\r\n\r\n            // Sterowanie kamera za pomoca myszy\r\n            const controls = new OrbitControls(camera, renderer.domElement);\r\n            controls.enableDamping = true;\r\n            controls.dampingFactor = 0.05;\r\n            controls.screenSpacePanning = false;\r\n            controls.minDistance = 10;\r\n            controls.maxDistance = 500;\r\n\r\n            // Postprocessing\r\n            const composer = new EffectComposer(renderer);\r\n            const renderPass = new RenderPass(scene, camera);\r\n            composer.addPass(renderPass);\r\n            const pass = new SMAAPass(window.innerWidth * renderer.getPixelRatio(), window.innerHeight * renderer.getPixelRatio());\r\n            composer.addPass(pass);\r\n\r\n            // Funkcja renderująca\r\n            const render = () => {\r\n                renderer.render(scene, camera);\r\n            };\r\n\r\n            // Główna pętla animacji\r\n            const animate = () => {\r\n                requestAnimationFrame(animate);\r\n\r\n                if (typeof mixer !== 'undefined') {\r\n                    mixer.update(clock.getDelta());\r\n                }\r\n\r\n                for (const model in mixers) {\r\n                    mixers[model].update(clock.getDelta());\r\n                }\r\n\r\n                // Jeżeli którykolwiek klawisz jest wciśnięty\r\n                if (Object.values(pressedKeys).includes(true)) {\r\n                    const keysStateResult = checkKeysState();\r\n                    objects['Robot'].position.add(keysStateResult.move);\r\n                    objects['Robot'].rotation.y = keysStateResult.angle * (Math.PI / 180);\r\n                }\r\n\r\n                controls.update();\r\n                //composer.render(); // Render postprocessingu\r\n                render(); // Render standardowy\r\n            };\r\n\r\n            animate();\r\n        })\r\n\r\n        onUnmounted(() => {\r\n            window.removeEventListener('keydown', keyDown);\r\n            window.removeEventListener('keyup', keyUp);\r\n        })\r\n\r\n        return {camera, renderer, scene, clock, raycaster, objects, mixers, animations, pressedKeys, sceneRef, playAnimation, stopAnimation, testAllKeys, testAnyKeys, checkKeysState, robotRunning, keyUp, keyDown}\r\n    }\r\n}\r\n</script>\r\n\r\n<style scoped lang=\"scss\">\r\n.scene {\r\n    width: 100vw;\r\n    height: 100vh;\r\n}\r\n\r\n.info {\r\n    z-index: 999;\r\n    background-color: white;\r\n    border: 1px solid black;\r\n    position: absolute;\r\n    right: 0;\r\n    top: 0;\r\n    text-align: left;\r\n}\r\n</style>\r\n","\r\n//import { Options, Vue } from 'vue-class-component';\r\nimport * as THREE from 'three';\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\r\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\r\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';\r\nimport { SMAAPass } from 'three/examples/jsm/postprocessing/SMAAPass.js';\r\n\r\nimport { ref, onMounted, onUnmounted } from 'vue'\r\n\r\nexport default {\r\n    setup() {\r\n        let camera!: THREE.PerspectiveCamera\r\n        const renderer: THREE.WebGLRenderer = new THREE.WebGLRenderer({ antialias: true });\r\n        const scene: THREE.Scene = new THREE.Scene();\r\n        const clock = new THREE.Clock();\r\n        const raycaster = new THREE.Raycaster();\r\n        const objects: any = {};\r\n        const mixers: any = {};\r\n        const animations: any = {};\r\n        const pressedKeys: any = {};\r\n        const sceneRef = ref(null);\r\n\r\n        const playAnimation = (objectMixer: any, objectAnimations: any, animationName: any, acceleration = 1, loop = true, weight = 1) => {\r\n            const clip = objectAnimations.find((el: any) => el.name === animationName);\r\n            const animation = objectMixer.clipAction(clip);\r\n            animation.timeScale = acceleration;\r\n            if (animations['Robot'][2].isPlaying) {\r\n                weight = 0;\r\n                setTimeout(() => {\r\n                    playAnimation(objectMixer, objectAnimations, animationName, acceleration, true, 1);\r\n                }, animations['Robot'][2].duration * 1000);\r\n            }\r\n            clip.isPlaying = true;\r\n            if (!loop) {\r\n                animation.setLoop(THREE.LoopOnce);\r\n                animation\r\n                    .reset()\r\n                    .setEffectiveTimeScale(0.5)\r\n                    .setEffectiveWeight(1) // wykombinować to ustawienie dla wszystkich animacji łączonych\r\n                    .play();\r\n            } else {\r\n                animation.setEffectiveWeight(weight).play();\r\n            }\r\n        }\r\n\r\n        const stopAnimation = (objectMixer: any, objectAnimations: any, animationName: any) => {\r\n            const clip = objectAnimations.find((el: any) => el.name === animationName);\r\n            const animation = objectMixer.clipAction(clip);\r\n            animation.stop();\r\n        }\r\n\r\n        const testAllKeys = (keysArray: any, exceptionKeysArray: any = null) => {\r\n            const activeInArray = keysArray.every((e: any) => pressedKeys[e] === true); // Czy klawisze z listy są wciąnięte\r\n            if (exceptionKeysArray) {\r\n                const exceptionInArray = exceptionKeysArray.every((e: any) => pressedKeys[e] === false || pressedKeys[e] === undefined);\r\n                return activeInArray && exceptionInArray;\r\n            }\r\n            return activeInArray;\r\n        };\r\n\r\n        const testAnyKeys = (keysArray: any) => {\r\n            return keysArray.some((e: any) => pressedKeys[e] === true);\r\n        };\r\n\r\n        const checkKeysState = () => {\r\n            const robotPosition = new THREE.Vector3(objects['Robot'].position.x, objects['Robot'].position.y, objects['Robot'].position.z);\r\n            const positionOffset = 5; // największa wysokość na jaką może wejść\r\n            robotPosition.y += positionOffset;\r\n            let speed = 0.18;\r\n            const distanceLimit = 6; // limit wielkości na jaką może wejść/zejść\r\n            let angle = 0;\r\n            const move = new THREE.Vector3();\r\n\r\n            if (testAllKeys(['ShiftLeft'])) {\r\n                speed *= 2;\r\n            }\r\n\r\n            if (testAllKeys(['KeyW'], ['KeyA', 'KeyS', 'KeyD'])) {\r\n                angle = 180;\r\n                move.z = -1 * speed;\r\n                robotPosition.z += -1 * speed;\r\n            } else if (testAllKeys(['KeyA'], ['KeyW', 'KeyS', 'KeyD'])) {\r\n                angle = -90;\r\n                move.x = -1 * speed;\r\n                robotPosition.x += -1 * speed;\r\n            } else if (testAllKeys(['KeyS'], ['KeyW', 'KeyA', 'KeyD'])) {\r\n                angle = 0;\r\n                move.z = 1 * speed;\r\n                robotPosition.z += 1 * speed;\r\n            } else if (testAllKeys(['KeyD'], ['KeyW', 'KeyA', 'KeyS'])) {\r\n                angle = 90;\r\n                move.x = 1 * speed;\r\n                robotPosition.x += 1 * speed;\r\n            } else if (testAllKeys(['KeyW', 'KeyA'])) {\r\n                angle = -135;\r\n                move.x = -1 * speed;\r\n                move.z = -1 * speed;\r\n                robotPosition.x += -1 * speed;\r\n                robotPosition.z += -1 * speed;\r\n            } else if (testAllKeys(['KeyW', 'KeyD'])) {\r\n                angle = 135;\r\n                move.x = 1 * speed;\r\n                move.z = -1 * speed;\r\n                robotPosition.x += 1 * speed;\r\n                robotPosition.z += -1 * speed;\r\n            } else if (testAllKeys(['KeyS', 'KeyA'])) {\r\n                angle = -45;\r\n                move.x = -1 * speed;\r\n                move.z = 1 * speed;\r\n                robotPosition.x += -1 * speed;\r\n                robotPosition.z += 1 * speed;\r\n            } else if (testAllKeys(['KeyS', 'KeyD'])) {\r\n                angle = 45;\r\n                move.x = 1 * speed;\r\n                move.z = 1 * speed;\r\n                robotPosition.x += 1 * speed;\r\n                robotPosition.z += 1 * speed;\r\n            }\r\n\r\n            // Wykrywanie kolizji\r\n            raycaster.set(robotPosition, new THREE.Vector3(0, -1, 0));\r\n            const intersects = raycaster.intersectObject(objects['floor'], true);\r\n\r\n            // Pokazuje promienie raycastera\r\n            //this.scene.add(new THREE.ArrowHelper(this.raycaster.ray.direction, this.raycaster.ray.origin, positionOffset, 0xff0000));\r\n\r\n            if (intersects[0] && intersects[0].distance - positionOffset < distanceLimit) {\r\n                move.y = -intersects[0].distance + positionOffset;\r\n                return { move, angle };\r\n            } else {\r\n                move.x = 0;\r\n                move.y = 0;\r\n                move.z = 0;\r\n                return { move, angle };\r\n            }\r\n        }\r\n\r\n        const robotRunning = () => {\r\n            if (mixers['Robot']) {\r\n                if (testAnyKeys(['KeyW', 'KeyA', 'KeyS', 'KeyD'])) {\r\n                    let acceleration = 1;\r\n                    if (testAllKeys(['ShiftLeft'])) {\r\n                        acceleration = 2;\r\n                    }\r\n                    playAnimation(mixers['Robot'], animations['Robot'], 'Robot_Running', acceleration);\r\n                } else {\r\n                    stopAnimation(mixers['Robot'], animations['Robot'], 'Robot_Running');\r\n                }\r\n\r\n                if (testAnyKeys(['Space'])) {\r\n                    playAnimation(mixers['Robot'], animations['Robot'], 'Robot_Jump', 1, false);\r\n                }\r\n            }\r\n        }\r\n\r\n        const keyUp = (e: any) => {\r\n            pressedKeys[e.code] = false;\r\n            robotRunning();\r\n        }\r\n\r\n        const keyDown = (e: any) => {\r\n            pressedKeys[e.code] = true;\r\n            robotRunning();\r\n        }\r\n\r\n        //Created\r\n        window.addEventListener('keydown', keyDown);\r\n        window.addEventListener('keyup', keyUp);\r\n\r\n        onMounted(() => {\r\n            const el = sceneRef.value as any;\r\n            camera = new THREE.PerspectiveCamera(60, el.clientWidth / el.clientHeight, 1, 1000);\r\n            camera.position.set(55, 55, 55);\r\n            renderer.setSize(el.clientWidth, el.clientHeight);\r\n            el.appendChild(renderer.domElement);\r\n\r\n            // Dodanie loadera plików\r\n            let mixer: any;\r\n            const loader = new GLTFLoader();\r\n\r\n            loader.load(\r\n                '/peach_castle/scene.gltf',\r\n                gltf => {\r\n                    const model = gltf.scene;\r\n                    scene.add(model);\r\n\r\n                    //Animacja\r\n                    if (gltf.animations.length) {\r\n                        mixer = new THREE.AnimationMixer(model);\r\n                        mixer.clipAction(gltf.animations[0]).play();\r\n                    }\r\n                },\r\n                undefined,\r\n                function(error) {\r\n                    console.error(error);\r\n                },\r\n            );\r\n\r\n            loader.load(\r\n                '/Robot.gltf',\r\n                gltf => {\r\n                    const model = gltf.scene;\r\n                    model.userData.name = 'Robot';\r\n                    scene.add(model);\r\n                    model.position.set(5, 12, 0);\r\n\r\n                    //Zapisz dane obiektu\r\n                    objects[model.userData.name] = model; // Obiekt\r\n                    animations[model.userData.name] = gltf.animations; // Animacja\r\n                    animations[model.userData.name].forEach((e: any) => {\r\n                        e.isPlaying = false;\r\n                    });\r\n                    mixers[model.userData.name] = new THREE.AnimationMixer(model); // Mikser animacji\r\n                    mixers[model.userData.name].addEventListener('finished', function(e: any) {\r\n                        e.action._clip.isPlaying = false;\r\n                        console.log('animacja skonczona');\r\n                    });\r\n                },\r\n                undefined,\r\n                function(error) {\r\n                    console.error(error);\r\n                },\r\n            );\r\n\r\n            loader.load(\r\n                '/peach_castle/floor.gltf',\r\n                gltf => {\r\n                    const model = gltf.scene;\r\n                    model.userData.name = 'floor';\r\n                    model.visible = false;\r\n                    scene.add(model);\r\n\r\n                    //Zapisz dane obiektu\r\n                    objects[model.userData.name] = model; // Obiekt\r\n                },\r\n                undefined,\r\n                function(error) {\r\n                    console.error(error);\r\n                },\r\n            );\r\n\r\n            // Dodanie światła\r\n            const ambientLight = new THREE.HemisphereLight(0xffffff, 0x222222, 1);\r\n            const mainLight = new THREE.DirectionalLight(0xffffff, 4.0);\r\n            mainLight.position.set(10, 10, 10);\r\n            scene.add(ambientLight, mainLight);\r\n\r\n            // Sterowanie kamera za pomoca myszy\r\n            const controls = new OrbitControls(camera, renderer.domElement);\r\n            controls.enableDamping = true;\r\n            controls.dampingFactor = 0.05;\r\n            controls.screenSpacePanning = false;\r\n            controls.minDistance = 10;\r\n            controls.maxDistance = 500;\r\n\r\n            // Postprocessing\r\n            const composer = new EffectComposer(renderer);\r\n            const renderPass = new RenderPass(scene, camera);\r\n            composer.addPass(renderPass);\r\n            const pass = new SMAAPass(window.innerWidth * renderer.getPixelRatio(), window.innerHeight * renderer.getPixelRatio());\r\n            composer.addPass(pass);\r\n\r\n            // Funkcja renderująca\r\n            const render = () => {\r\n                renderer.render(scene, camera);\r\n            };\r\n\r\n            // Główna pętla animacji\r\n            const animate = () => {\r\n                requestAnimationFrame(animate);\r\n\r\n                if (typeof mixer !== 'undefined') {\r\n                    mixer.update(clock.getDelta());\r\n                }\r\n\r\n                for (const model in mixers) {\r\n                    mixers[model].update(clock.getDelta());\r\n                }\r\n\r\n                // Jeżeli którykolwiek klawisz jest wciśnięty\r\n                if (Object.values(pressedKeys).includes(true)) {\r\n                    const keysStateResult = checkKeysState();\r\n                    objects['Robot'].position.add(keysStateResult.move);\r\n                    objects['Robot'].rotation.y = keysStateResult.angle * (Math.PI / 180);\r\n                }\r\n\r\n                controls.update();\r\n                //composer.render(); // Render postprocessingu\r\n                render(); // Render standardowy\r\n            };\r\n\r\n            animate();\r\n        })\r\n\r\n        onUnmounted(() => {\r\n            window.removeEventListener('keydown', keyDown);\r\n            window.removeEventListener('keyup', keyUp);\r\n        })\r\n\r\n        return {camera, renderer, scene, clock, raycaster, objects, mixers, animations, pressedKeys, sceneRef, playAnimation, stopAnimation, testAllKeys, testAnyKeys, checkKeysState, robotRunning, keyUp, keyDown}\r\n    }\r\n}\r\n","import { render } from \"./Scene.vue?vue&type=template&id=549912f1&scoped=true\"\nimport script from \"./Scene.vue?vue&type=script&lang=ts\"\nexport * from \"./Scene.vue?vue&type=script&lang=ts\"\n\nimport \"./Scene.vue?vue&type=style&index=0&id=549912f1&scoped=true&lang=scss\"\nscript.render = render\nscript.__scopeId = \"data-v-549912f1\"\n\nexport default script","<template>\r\n    <div class=\"container\">\r\n        <div class=\"preloader\" v-show=\"loading.progress < 100\">\r\n            <div>\r\n                Ładowanie\r\n                <span v-show=\"loading.total\">{{ loading.loaded }}/{{ loading.total }}</span>\r\n            </div>\r\n            <div v-show=\"loading.total\">{{ loading.progress }}%</div>\r\n        </div>\r\n\r\n        <div class=\"popup-wrapper\" v-if=\"popup && loading.progress == 100\">\r\n            <div class=\"popup\">\r\n                <div class=\"title\">Sterowanie</div>\r\n                <div>WASD - chodzenie</div>\r\n                <div>SHIFT - bieganie</div>\r\n                <div>SPACE - skok (w trakcie dopracowania)</div>\r\n                <div>Można także podłaczyć pada (testowane na padach z Xbox 360)</div>\r\n                <button class=\"close\" v-on:click=\"popup=false\">X</button>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"scene\" ref=\"sceneRef\" :class=\"{'blur': loading.progress < 100}\"></div>\r\n    </div>\r\n</template>\r\n\r\n<script lang=\"ts\">\r\nimport * as THREE from 'three';\r\nimport createScene from '../hooks/createScene';\r\nimport addLights from '../hooks/addLights';\r\nimport postProduction from '../hooks/postProduction';\r\nimport addMap from '../hooks/addMap';\r\nimport addCharacter from '../hooks/addCharacter';\r\nimport keysControls from '../hooks/keysControls';\r\nimport addLoaderManager from '../hooks/addLoaderManager';\r\nimport { publicPath } from '../../vue.config';\r\n\r\nimport { ref } from 'vue';\r\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\r\nimport { Vector3 } from 'three';\r\n\r\n//import * as dat from 'dat.gui';\r\n\r\nexport default {\r\n    setup() {\r\n        const popup = ref(false);\r\n\r\n        //const gui = new dat.GUI();\r\n        // Zmienne sceny\r\n        // const characterPosition = new Vector3(5, 11.5, 0);\r\n        const characterPosition = new Vector3(0, 0, 0);\r\n        //const cameraOffset = new Vector3(5, 30, 50); // wektor przesunięcia kamery względem postaci\r\n        const cameraOffset = new Vector3(2.5, 15, 25);\r\n        // const cameraOffset = new Vector3(-35, 15, 15);\r\n\r\n        // Dodaj scenę\r\n        const sceneRef = ref(null);\r\n        const { scene, renderer, camera, animateFunctions, animation, controls } = createScene(sceneRef, characterPosition, cameraOffset);\r\n\r\n        // Dodaj światła\r\n        addLights(scene);\r\n\r\n        // Dodaj postprodukcję\r\n        postProduction(scene, camera, renderer)\r\n\r\n        // Dodaj manager ładowania\r\n        const manager = new THREE.LoadingManager();\r\n        const { loading } = addLoaderManager(manager)\r\n\r\n        // Załaduj główną mapę\r\n        const loader = new GLTFLoader(manager);\r\n        const objects: any = {};\r\n        // addMap(loader, scene, objects, `${publicPath}peach_castle/scene.gltf`, `${publicPath}peach_castle/floor.gltf`);\r\n        addMap(loader, scene, objects, `${publicPath}islands/islands.gltf`, `${publicPath}islands/islands_physics.gltf`);\r\n\r\n        // Wczytaj funkcje obsługi klawiszy i padów\r\n        const pressedKeys: any = {};\r\n\r\n        const { testAllKeys, testAnyKeys, keysFunctions, checkPressedKeys, testAllButtons, testAnyButton, testAxis, checkPads, gamepads} = keysControls(pressedKeys);\r\n        animateFunctions.push(checkPressedKeys, checkPads)\r\n\r\n        // Wczytaj postać z funkcjami ruchu i animacji\r\n        const animations: any = {};\r\n        const mixers: any = {};\r\n        const { robotRunning, toAnimate } = addCharacter(\r\n            loader, scene, objects, animations, mixers,\r\n            pressedKeys, testAllKeys, testAnyKeys,\r\n            gamepads, testAllButtons, testAnyButton, testAxis, `${publicPath}Robot_edited_centered.glb`,\r\n            controls, camera, characterPosition, cameraOffset, animation\r\n        );\r\n        animateFunctions.push(toAnimate);\r\n        keysFunctions.push(robotRunning);\r\n\r\n        return {\r\n            sceneRef,\r\n            loading,\r\n            popup,\r\n            close,\r\n            camera,\r\n            animations,\r\n            mixers\r\n        }\r\n    }\r\n}\r\n</script>\r\n\r\n<style scoped lang=\"scss\">\r\n.scene {\r\n    width: 100vw;\r\n    height: 100vh;\r\n    transition: filter 0.3s;\r\n\r\n    canvas {\r\n        width: 100vw;\r\n        height: 100vh;\r\n        display: block;\r\n    }\r\n}\r\n\r\n.info {\r\n    z-index: 999;\r\n    background-color: white;\r\n    border: 1px solid black;\r\n    position: absolute;\r\n    right: 0;\r\n    top: 0;\r\n    text-align: left;\r\n}\r\n\r\n.preloader {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    z-index: 998;\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center;\r\n    justify-content: center;\r\n    font-size: 20px;\r\n    font-weight: bold;\r\n    color: white;\r\n}\r\n\r\n.blur {\r\n    filter: blur(20px);\r\n}\r\n\r\n.popup-wrapper {\r\n    position: absolute;\r\n    bottom: 20px;\r\n    left: 50%;\r\n    transform: translateX(-50%);\r\n    background: #ffffffcc;\r\n    padding: 20px;\r\n    border-radius: 10px;\r\n    line-height: 1.5;\r\n}\r\n\r\n.popup {\r\n    position: relative;\r\n\r\n    .close {\r\n        position: absolute;\r\n        top: -10px;\r\n        right: -10px;\r\n        border: none;\r\n        border-radius: 100%;\r\n        padding: 5px;\r\n        width: 30px;\r\n        height: 30px;\r\n        font-weight: bold;\r\n        box-shadow: 0 0px 8px 0px rgb(189 183 183);\r\n        cursor: pointer;\r\n    }\r\n}\r\n\r\n.title {\r\n    font-weight: bold;\r\n    text-align: center;\r\n    margin-bottom: 15px;\r\n    text-transform: uppercase;\r\n}\r\n</style>\r\n","import { onMounted, onUnmounted, ref } from 'vue';\r\nimport * as THREE from 'three';\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\nimport Stats from 'stats.js'\r\nimport { Vector3 } from 'three';\r\n\r\nexport default function createScene(sceneRef: any, characterPosition: Vector3, cameraOffset: Vector3) {\r\n    const scene: THREE.Scene = new THREE.Scene();\r\n    const renderer: THREE.WebGLRenderer = new THREE.WebGLRenderer({ antialias: true });\r\n    const camera: THREE.PerspectiveCamera = new THREE.PerspectiveCamera();\r\n    const animation = ref();\r\n    const animateFunctions: Array<any> = [];\r\n    const controls: OrbitControls = new OrbitControls(camera, renderer.domElement);\r\n    let scaleFactor = 1\r\n    let clientWidth = window.innerWidth\r\n    let clientHeight = window.innerHeight\r\n    const maxClientWidth = 1920\r\n    const maxClientHeight = 1080\r\n\r\n    const onWindowResize = () => {\r\n        camera.aspect = clientWidth / clientHeight;\r\n        camera.updateProjectionMatrix();\r\n        renderer.setSize(clientWidth, clientHeight);\r\n        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2) * scaleFactor);\r\n    }\r\n\r\n    onMounted( () => {\r\n        clientWidth = sceneRef.value.clientWidth\r\n        clientHeight = sceneRef.value.clientHeight\r\n        if(clientWidth > maxClientWidth || clientHeight > maxClientHeight) {\r\n            scaleFactor = Math.min(maxClientWidth/clientWidth, maxClientHeight/clientHeight)\r\n        }\r\n        camera.fov = 60;\r\n        camera.aspect = clientWidth / clientHeight\r\n        camera.near = 1;\r\n        camera.far = 300;\r\n        camera.position.set(characterPosition.x + cameraOffset.x, characterPosition.y + cameraOffset.y, characterPosition.z + cameraOffset.z);\r\n        camera.updateProjectionMatrix();\r\n        renderer.setSize(clientWidth, clientHeight);\r\n        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2) * scaleFactor);\r\n        renderer.shadowMap.enabled = true;\r\n        renderer.shadowMap.type = THREE.PCFSoftShadowMap;\r\n        sceneRef.value.appendChild(renderer.domElement);\r\n        scene.background = new THREE.Color(0x44b1ff);\r\n        scene.fog = new THREE.Fog(0x44b1ff, 100, 300);\r\n\r\n        // zmiana rozmiaru sceny\r\n        window.addEventListener('resize', onWindowResize);\r\n\r\n        // Panel statystyk\r\n        const stats = new Stats();\r\n        stats.showPanel(0);\r\n        document.body.appendChild( stats.dom );\r\n\r\n        // Sterowanie kamera za pomoca myszy\r\n        controls.enableDamping = true;\r\n        controls.dampingFactor = 0.05;\r\n        controls.screenSpacePanning = false;\r\n        controls.minDistance = 10;\r\n        controls.maxDistance = 30;\r\n        controls.maxPolarAngle = 75* Math.PI/180\r\n        controls.enablePan = false;\r\n        // controls.enableRotate = false;\r\n        controls.enableZoom = false;\r\n        controls.target = characterPosition\r\n\r\n        // Funkcja renderująca\r\n        const render = () => {\r\n            renderer.render(scene, camera);\r\n        };\r\n\r\n        // Główna pętla animacji\r\n        const animate = () => {\r\n            stats.begin();\r\n\r\n            requestAnimationFrame(animate);\r\n            controls.update();\r\n\r\n            animateFunctions.forEach(func => {\r\n                func();\r\n            });\r\n\r\n            render();\r\n\r\n            stats.end();\r\n        };\r\n\r\n        animate();\r\n    });\r\n\r\n    onUnmounted(() => {\r\n        window.removeEventListener('resize', onWindowResize);\r\n    })\r\n\r\n    return {\r\n        scene,\r\n        renderer,\r\n        camera,\r\n        animateFunctions,\r\n        animation,\r\n        controls\r\n    };\r\n}","import { onMounted } from 'vue';\r\nimport * as THREE from 'three';\r\n\r\nexport default function addLights(scene: THREE.Scene) {\r\n\r\n    onMounted( () => {\r\n        const ambientLight = new THREE.HemisphereLight(0xffffff, 0x222222, 0.5);\r\n        const mainLight = new THREE.DirectionalLight(0xffffff, 0.7);\r\n        mainLight.position.set(1, 1.5, 1).multiplyScalar(100);\r\n        mainLight.shadow.mapSize.setScalar(3072);\r\n        mainLight.shadow.bias = -0.001;\r\n        mainLight.shadow.normalBias = 0.05;\r\n        mainLight.castShadow = true;\r\n\r\n        const shadowCam = mainLight.shadow.camera;\r\n        shadowCam.bottom = shadowCam.left = -300;\r\n        shadowCam.top = 300;\r\n        shadowCam.right = 300;\r\n\r\n        // const mainLightHelper = new THREE.DirectionalLightHelper(mainLight, 5);\r\n        // scene.add(mainLightHelper);\r\n\r\n        // const mainLightCameraHelper = new THREE.CameraHelper(shadowCam);\r\n        // scene.add(mainLightCameraHelper);\r\n\r\n        scene.add(ambientLight, mainLight);\r\n    });\r\n}","import { onMounted } from 'vue';\r\nimport * as THREE from 'three';\r\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\r\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';\r\nimport { SMAAPass } from 'three/examples/jsm/postprocessing/SMAAPass.js';\r\n\r\nexport default function postProduction(scene: THREE.Scene, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer) {\r\n\r\n    onMounted( () => {\r\n        const composer = new EffectComposer(renderer);\r\n        const renderPass = new RenderPass(scene, camera);\r\n        composer.addPass(renderPass);\r\n        const pass = new SMAAPass(window.innerWidth * renderer.getPixelRatio(), window.innerHeight * renderer.getPixelRatio());\r\n        composer.addPass(pass);\r\n    });\r\n}","import { onMounted } from 'vue';\r\nimport * as THREE from 'three';\r\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\r\nimport { BufferGeometryUtils } from 'three/examples/jsm/utils/BufferGeometryUtils.js';\r\nimport { MeshBVH, MeshBVHVisualizer } from 'three-mesh-bvh';\r\n\r\nexport default function addMap(loader: GLTFLoader, scene: THREE.Scene, objects: any, mapPath: string, collisionMapPath: string) {\r\n    onMounted( () => {\r\n\r\n        loader.load(\r\n            mapPath,\r\n            gltf => {\r\n                const model = gltf.scene;\r\n\r\n                const box = new THREE.Box3();\r\n                box.setFromObject(model);\r\n                box.getCenter(model.position).negate();\r\n                model.updateMatrixWorld(true);\r\n\r\n                const toMerge = {};\r\n                model.traverse(child => {\r\n                    if (child instanceof THREE.Mesh) {\r\n                        const hex = child.material.color.getHex();\r\n                        toMerge[hex] = toMerge[hex] || [];\r\n                        toMerge[hex].push(child);\r\n                        child.castShadow = true;\r\n                        child.receiveShadow = true;\r\n                        child.material.shadowSide = 2;\r\n                    }\r\n                });\r\n\r\n                const environment = new THREE.Group();\r\n                for (const hex in toMerge) {\r\n                    const arr = toMerge[hex];\r\n                    const visualGeometries = [];\r\n                    arr.forEach(mesh => {\r\n                        if (mesh.material.emissive.r !== 0) {\r\n                            environment.attach(mesh);\r\n                        } else {\r\n                            const geom = mesh.geometry.clone();\r\n                            geom.applyMatrix4(mesh.matrixWorld);\r\n                            visualGeometries.push(geom as never);\r\n                        }\r\n                    });\r\n\r\n                    if (visualGeometries.length) {\r\n                        const newGeom = BufferGeometryUtils.mergeBufferGeometries(visualGeometries);\r\n                        const newMesh = new THREE.Mesh(newGeom, new THREE.MeshStandardMaterial({ color: 0xffffff, opacity: 0, transparent: true, depthWrite: false }));\r\n\r\n                        newMesh.castShadow = true;\r\n                        newMesh.receiveShadow = true;\r\n                        newMesh.material.shadowSide = 2;\r\n\r\n                        environment.add(newMesh);\r\n                    }\r\n                }\r\n\r\n                // collect all geometries to merge\r\n                const geometries = [];\r\n                environment.updateMatrixWorld(true);\r\n                environment.traverse(child=> {\r\n                    if (child instanceof THREE.Mesh) {\r\n                        const cloned = child.geometry.clone();\r\n                        cloned.applyMatrix4( child.matrixWorld );\r\n                        for (const key in cloned.attributes) {\r\n                            if (key !== 'position') {\r\n                                cloned.deleteAttribute(key);\r\n                            }\r\n                        }\r\n                        geometries.push(cloned as never);\r\n                    }\r\n                });\r\n\r\n                // create the merged geometry\r\n                const mergedGeometry = BufferGeometryUtils.mergeBufferGeometries(geometries, false);\r\n                (mergedGeometry as any).boundsTree = new MeshBVH(mergedGeometry, {lazyGeneration: false});\r\n\r\n                const collider = new THREE.Mesh(mergedGeometry);\r\n                (collider.material as THREE.MeshStandardMaterial).wireframe = true;\r\n                (collider.material as THREE.MeshStandardMaterial).opacity = 0.5;\r\n                (collider.material as THREE.MeshStandardMaterial).transparent = true;\r\n\r\n                collider.userData.name = 'collider';\r\n                objects[collider.userData.name] = collider;\r\n\r\n                const visualizer = new MeshBVHVisualizer(collider, 1000);\r\n                visualizer.visible = true\r\n                scene.add(model);\r\n                //scene.add(visualizer)\r\n                //scene.add(collider);\r\n                //scene.add(environment);\r\n            },\r\n            undefined,\r\n            function(error) {\r\n                console.error(error);\r\n            },\r\n        );\r\n\r\n        loader.load(\r\n            collisionMapPath,\r\n            gltf => {\r\n                const model = gltf.scene;\r\n                model.userData.name = 'floor';\r\n                model.visible = false;\r\n                scene.add(model);\r\n\r\n                //Zapisz dane obiektu\r\n                objects[model.userData.name] = model; // Obiekt\r\n            },\r\n            undefined,\r\n            function(error) {\r\n                console.error(error);\r\n            },\r\n        );\r\n    });\r\n}","import { onMounted, Ref } from 'vue';\r\nimport * as THREE from 'three';\r\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\nimport { AnimationAction, Object3D, Vector3 } from 'three';\r\nimport anime from 'animejs';\r\n\r\nexport default function addCharacter(\r\n    loader: GLTFLoader,\r\n    scene: THREE.Scene,\r\n    objects: any,\r\n    animations: any,\r\n    mixers: any,\r\n    pressedKeys: any,\r\n    testAllKeys: any,\r\n    testAnyKeys: any,\r\n    gamepads: Ref<(Gamepad | null)[]>,\r\n    testAllButtons: any,\r\n    testAnyButton: any,\r\n    testAxis: any,\r\n    characterPath: string,\r\n    controls: OrbitControls,\r\n    camera: THREE.PerspectiveCamera,\r\n    position: Vector3,\r\n    cameraOffset: Vector3,\r\n    animation: Ref\r\n) {\r\n\r\n    //const raycaster = new THREE.Raycaster();\r\n    const clock = new THREE.Clock();\r\n    let pauseOthersAnimations = false;\r\n\r\n    const tempBox = new THREE.Box3();\r\n    const tempMatrix = new THREE.Matrix4();\r\n    const tempSegment = new THREE.Line3();\r\n    const tempVector = new THREE.Vector3();\r\n    const tempVector2 = new THREE.Vector3();\r\n    const upVector = new THREE.Vector3(0, 1, 0);\r\n    const gravity = -2\r\n\r\n    let currentAnimation: AnimationAction | null = null;\r\n    //let oneLoopTrigger = 0\r\n\r\n    const playAnimation = (objectMixer: any, objectAnimations: any, animationName: any, acceleration = 1, loop = true) => {\r\n        const clip = objectAnimations.find((el: any) => el.name === animationName);\r\n        const animation = objectMixer.clipAction(clip);\r\n        animation.setEffectiveTimeScale(acceleration);\r\n\r\n        if(!loop && animation.time == animation.getClip().duration) {\r\n            animation.reset()\r\n        }\r\n\r\n        if (!loop && animation != currentAnimation) {\r\n            pauseOthersAnimations = true;\r\n            animation.setLoop(THREE.LoopOnce, 1);\r\n            animation.setEffectiveWeight(1).reset()\r\n            currentAnimation?.fadeOut(getFadeTime(currentAnimation, animation))\r\n            currentAnimation = animation\r\n\r\n            // animation.value = anime({\r\n            //     targets: objects['Robot'].position,\r\n            //     easing: 'linear',\r\n            //     direction: 'alternate',\r\n            //     duration: animation.getClip().duration*1000 / 2,\r\n            //     update: () => {\r\n            //         const distance = raycaster.intersectObject(objects['floor'], true)[0].distance - 4\r\n            //         console.log(objects['Robot'].position.y)\r\n            //         console.log('distance', distance)\r\n            //     },\r\n            //     complete: () => {\r\n            //         animation.value = null;\r\n            //     },\r\n            //     y: objects['Robot'].position.y + 5,\r\n            // });\r\n        }\r\n\r\n        if (pauseOthersAnimations) {\r\n            if(currentAnimation && currentAnimation.time/currentAnimation.getClip().duration >= 0.75) {\r\n                pauseOthersAnimations = false\r\n                animation.fadeIn(getFadeTime(animation, currentAnimation)).reset()\r\n                currentAnimation = animation\r\n            }\r\n        } else {\r\n            animation.setEffectiveWeight(1)\r\n            currentAnimation = animation\r\n        }\r\n    }\r\n\r\n    const getFadeTime = (startAnimation: AnimationAction, endAnimation: AnimationAction) => {\r\n        const startAnimationTime = startAnimation.getClip().duration / startAnimation.getEffectiveTimeScale()\r\n        const endAnimationTime = endAnimation.getClip().duration / endAnimation.getEffectiveTimeScale()\r\n\r\n        if (endAnimationTime * 0.25 > startAnimationTime) {\r\n            return startAnimationTime\r\n        } else {\r\n            return endAnimationTime * 0.25\r\n        }\r\n    }\r\n\r\n    const stopAnimation = (objectMixer: any, objectAnimations: any, animationName: any) => {\r\n        const clip = objectAnimations.find((el: any) => el.name === animationName);\r\n        const animation = objectMixer.clipAction(clip);\r\n        animation.setEffectiveWeight(0)\r\n    }\r\n\r\n    const updateCameraPosition = () => {\r\n        // animation.value = anime({\r\n        //     targets: camera.position,\r\n        //     easing: 'easeOutCirc',\r\n        //     duration: 1000,\r\n        //     complete: () => {\r\n        //         animation.value = null;\r\n        //     },\r\n        //     x: objects['Robot'].position.x + cameraOffset.x,\r\n        //     y: objects['Robot'].position.y + cameraOffset.y,\r\n        //     z: objects['Robot'].position.z + cameraOffset.z\r\n        // });\r\n\r\n        animation.value = anime({\r\n            targets: controls.target,\r\n            easing: 'easeOutCirc',\r\n            duration: 2000,\r\n            complete: () => {\r\n                animation.value = null;\r\n            },\r\n            x: objects['Robot'].position.x,\r\n            y: objects['Robot'].position.y,\r\n            z: objects['Robot'].position.z,\r\n        });\r\n    }\r\n\r\n    // const getCoordsFromAngle = (angle: number) => {\r\n    //     const z = Math.cos(angle * Math.PI / 180)\r\n    //     const x = Math.sin(angle * Math.PI / 180)\r\n    //     return {z, x}\r\n    // }\r\n\r\n    const player = new THREE.Mesh(\r\n        new THREE.BoxGeometry(1, 5, 1),\r\n        new THREE.MeshStandardMaterial()\r\n    );\r\n\r\n    const checkKeysState = () => {\r\n        const collider = objects['collider']\r\n        const delta = 0.1;\r\n        const player = objects['Robot']\r\n        let speed =  player.userData.speed\r\n        player.userData.velocity.y += delta * gravity;\r\n        player.position.addScaledVector(player.userData.velocity, delta);\r\n        const oneLoop = currentAnimation?.loop == 2200\r\n\r\n        const angle = controls.getAzimuthalAngle();\r\n        const cameraAngle = angle * 180/Math.PI\r\n        const robotRotation = objects['Robot'].rotation.y * 180 / Math.PI\r\n        let robotAngle = robotRotation\r\n\r\n        if ((testAllKeys(['ShiftLeft']) || testAllButtons([7])) && !oneLoop) {\r\n            speed *= 2;\r\n        }\r\n\r\n        if (testAllKeys(['KeyW'], ['KeyA', 'KeyS', 'KeyD']) || testAllButtons([12], [13,14,15])) {\r\n            tempVector.set(0, 0, -1).applyAxisAngle(upVector, angle);\r\n            player.position.addScaledVector(tempVector, speed * delta);\r\n            robotAngle = 180 + cameraAngle;\r\n        }\r\n\r\n        if (testAllKeys(['KeyA'], ['KeyW', 'KeyS', 'KeyD']) || testAllButtons([14], [12,13,15])) {\r\n            tempVector.set(-1, 0, 0).applyAxisAngle(upVector, angle);\r\n            player.position.addScaledVector(tempVector, speed * delta);\r\n            robotAngle = -90 + cameraAngle;\r\n        }\r\n\r\n        if (testAllKeys(['KeyS'], ['KeyW', 'KeyA', 'KeyD']) || testAllButtons([13], [12,14,15])) {\r\n            tempVector.set(0, 0, 1).applyAxisAngle(upVector, angle);\r\n            player.position.addScaledVector(tempVector,speed * delta);\r\n            robotAngle = 0 + cameraAngle;\r\n        }\r\n\r\n        if (testAllKeys(['KeyD'], ['KeyW', 'KeyA', 'KeyS']) || testAllButtons([15], [12,13,14])) {\r\n            tempVector.set(1, 0, 0).applyAxisAngle(upVector, angle);\r\n            player.position.addScaledVector(tempVector, speed * delta);\r\n            robotAngle = 90 + cameraAngle;\r\n        }\r\n\r\n        if (testAllKeys(['KeyW', 'KeyA']) || testAllButtons([12, 14])) {\r\n            tempVector.set(-1, 0, -1).applyAxisAngle(upVector, angle);\r\n            player.position.addScaledVector(tempVector, speed * delta);\r\n            robotAngle = -135 + cameraAngle;\r\n        }\r\n\r\n        if (testAllKeys(['KeyW', 'KeyD']) || testAllButtons([12, 15])) {\r\n            tempVector.set(1, 0, -1).applyAxisAngle(upVector, angle);\r\n            player.position.addScaledVector(tempVector, speed * delta);\r\n            robotAngle = 135 + cameraAngle;\r\n        }\r\n\r\n        if (testAllKeys(['KeyS', 'KeyA']) || testAllButtons([13, 14])) {\r\n            tempVector.set(-1, 0, 1).applyAxisAngle(upVector, angle);\r\n            player.position.addScaledVector(tempVector, speed * delta);\r\n            robotAngle = -45 + cameraAngle;\r\n        }\r\n\r\n        if (testAllKeys(['KeyS', 'KeyD']) || testAllButtons([13, 15])) {\r\n            tempVector.set(1, 0, 1).applyAxisAngle(upVector, angle);\r\n            player.position.addScaledVector(tempVector, speed * delta);\r\n            robotAngle = 45 + cameraAngle;\r\n        }\r\n        player.rotation.y = robotAngle * (Math.PI / 180);\r\n\r\n        player.updateMatrixWorld();\r\n        const height = 4.5\r\n        const width = 2.35\r\n        const radius = height/2\r\n        const skeletonExtremes = getSkeletonExtremes(objects['Robot'])\r\n        const robotHeight = skeletonExtremes.max.y-skeletonExtremes.min.y // wysokość postaci\r\n        const palyerBbox = new THREE.Box3().setFromObject(objects['Robot']);\r\n        const playerCenter = skeletonExtremes.min.lerp(skeletonExtremes.max, 0.5)\r\n        const segment = new THREE.Line3(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0))\r\n        tempBox.makeEmpty();\r\n        tempMatrix.copy(collider.matrixWorld).invert();\r\n        tempSegment.copy(segment);\r\n\r\n        tempSegment.start.applyMatrix4(player.matrixWorld).applyMatrix4(tempMatrix);\r\n        tempSegment.end.applyMatrix4(player.matrixWorld).applyMatrix4(tempMatrix);\r\n\r\n        tempBox.expandByPoint(tempSegment.start);\r\n        tempBox.expandByPoint(tempSegment.end);\r\n\r\n        // tempBox.min.addScalar(-radius);\r\n        // tempBox.max.addScalar(radius);\r\n        tempBox.min.sub(new THREE.Vector3(width/2, height/2, width/2));\r\n        tempBox.max.sub(new THREE.Vector3(-width/2, -height/2, -width/2));\r\n\r\n        // const tempBoxHelper = new THREE.Box3Helper(tempBox, new THREE.Color(0x0000ff));\r\n        // scene.add(tempBoxHelper);\r\n        // setTimeout(() => {\r\n        //     scene.remove(tempBoxHelper)\r\n        // }, 1000);\r\n\r\n        // const robotPhelper = new THREE.Mesh(new THREE.SphereGeometry( 0.1, 8, 8 ), new THREE.MeshBasicMaterial( {color: 0x00ff00} ));\r\n        // robotPhelper.position.set(player.position.x, player.position.y, player.position.z)\r\n        // scene.add(robotPhelper)\r\n        // setTimeout(() => {\r\n        //     scene.remove(robotPhelper)\r\n        // }, 1000);\r\n\r\n\r\n        // tempVector - najbliższy punkt na siatce (czerwony)\r\n        // tempVector2 - najbliższy punkt na obiekcie (niebieski)\r\n        collider.geometry.boundsTree.shapecast(\r\n            collider,\r\n            box => box.intersectsBox(tempBox), // box - najbliższy bvh z którym zachodzi kolizja\r\n            tri => { // tri - najbliższy trójkąt w bvh z którym zaszła kolizja\r\n                const distance = tri.closestPointToSegment(tempSegment, tempVector, tempVector2);\r\n\r\n                // const tempVectorHelper = new THREE.Mesh(new THREE.SphereGeometry( 0.1, 8, 8 ), new THREE.MeshBasicMaterial( {color: 0xff0000} ));\r\n                // tempVectorHelper.position.set(tempVector.x, tempVector.y, tempVector.z)\r\n                // scene.add(tempVectorHelper)\r\n                // setTimeout(() => {\r\n                //     scene.remove(tempVectorHelper)\r\n                // }, 1000);\r\n\r\n                // const tempVector2Helper = new THREE.Mesh(new THREE.SphereGeometry( 0.1, 8, 8 ), new THREE.MeshBasicMaterial( {color: 0x0000ff} ));\r\n                // tempVector2Helper.position.set(tempVector2.x, tempVector2.y, tempVector2.z)\r\n                // scene.add(tempVector2Helper)\r\n                // setTimeout(() => {\r\n                //     scene.remove(tempVector2Helper)\r\n                // }, 1000);\r\n\r\n\r\n                if (distance < radius) {\r\n                    const depth = radius - distance;\r\n                    const direction = tempVector2.sub(tempVector).normalize(); // normalize - tworzy kierunek z wektora o dowolnej długości\r\n\r\n                    tempSegment.start.addScaledVector(direction, depth);\r\n                    tempSegment.end.addScaledVector(direction, depth);\r\n                }\r\n            }\r\n        );\r\n\r\n        // const tempVectorHelper = new THREE.Mesh(new THREE.SphereGeometry( 0.1, 8, 8 ), new THREE.MeshBasicMaterial( {color: 0xff0000} ));\r\n        // tempVectorHelper.position.set(tempSegment.start.x, tempSegment.start.y, tempSegment.start.z)\r\n        // scene.add(tempVectorHelper)\r\n        // setTimeout(() => {\r\n        //     scene.remove(tempVectorHelper)\r\n        // }, 1000);\r\n\r\n        const newPosition = tempVector;\r\n        newPosition.copy(tempSegment.start).applyMatrix4(collider.matrixWorld);\r\n        const deltaVector = tempVector2;\r\n        deltaVector.subVectors(newPosition, player.position);\r\n\r\n        player.position.copy(newPosition);\r\n\r\n        player.userData.isOnGround = deltaVector.y > Math.abs(delta * player.userData.velocity.y * 0.25);\r\n\r\n        if (!player.userData.isOnGround) {\r\n            deltaVector.normalize();\r\n            player.userData.velocity.addScaledVector(deltaVector, -deltaVector.dot(player.userData.velocity));\r\n        } else {\r\n            player.userData.velocity.set(0, 0, 0);\r\n        }\r\n\r\n        // const robotPosition = objects['Robot'].position.clone()\r\n        // const robotRotation = objects['Robot'].rotation.y * 180 / Math.PI\r\n        // const skeletonExtremes = getSkeletonExtremes(objects['Robot'])\r\n        // const robotHeight = skeletonExtremes.max.y-skeletonExtremes.min.y // wysokość postaci\r\n        // const raycasterPosition = robotPosition.clone()\r\n        // raycasterPosition.y += robotHeight;\r\n        // let speed = 0.18;\r\n        //const horizontalOffset = 1; // powinien wynosić promień poziomy postaci\r\n        //const distanceLimitUp = 1.2; // limit wielkości na jaką może wejść (bez skoku)\r\n        //const distanceLimitDown = 5; // limit wielkości z jakiej może zejść\r\n        //let angle = robotRotation;\r\n        //const move = new THREE.Vector3();\r\n        //const oneLoop = currentAnimation?.loop == 2200\r\n        //const axis = testAxis()\r\n        //const cameraAngle = controls.getAzimuthalAngle() * 180/Math.PI\r\n\r\n\r\n        // const robotPositionHelper = new THREE.Mesh(new THREE.SphereGeometry( 0.1, 8, 8 ), new THREE.MeshBasicMaterial( {color: 0xff0000} ));\r\n        // robotPositionHelper.position.set(robotPosition.x, robotPosition.y, robotPosition.z)\r\n        // scene.add(robotPositionHelper)\r\n        // setTimeout(() => {\r\n        //     scene.remove(robotPositionHelper)\r\n        // }, 300);\r\n\r\n        // if ((testAllKeys(['ShiftLeft']) || testAllButtons([7])) && !oneLoop) {\r\n        //     speed *= 2;\r\n        // }\r\n\r\n        // if (testAllKeys(['KeyW'], ['KeyA', 'KeyS', 'KeyD']) || testAllButtons([12], [13,14,15])) {\r\n        //     angle = 180 + cameraAngle;\r\n        // } else if (testAllKeys(['KeyA'], ['KeyW', 'KeyS', 'KeyD']) || testAllButtons([14], [12,13,15])) {\r\n        //     angle = -90 + cameraAngle;\r\n        // } else if (testAllKeys(['KeyS'], ['KeyW', 'KeyA', 'KeyD']) || testAllButtons([13], [12,14,15])) {\r\n        //     angle = 0 + cameraAngle;\r\n        // } else if (testAllKeys(['KeyD'], ['KeyW', 'KeyA', 'KeyS']) || testAllButtons([15], [12,13,14])) {\r\n        //     angle = 90 + cameraAngle;\r\n        // } else if (testAllKeys(['KeyW', 'KeyA']) || testAllButtons([12, 14])) {\r\n        //     angle = -135 + cameraAngle;\r\n        // } else if (testAllKeys(['KeyW', 'KeyD']) || testAllButtons([12, 15])) {\r\n        //     angle = 135 + cameraAngle;\r\n        // } else if (testAllKeys(['KeyS', 'KeyA']) || testAllButtons([13, 14])) {\r\n        //     angle = -45 + cameraAngle;\r\n        // } else if (testAllKeys(['KeyS', 'KeyD']) || testAllButtons([13, 15])) {\r\n        //     angle = 45 + cameraAngle;\r\n        // }\r\n\r\n        // if (testAnyKeys(['KeyW', 'KeyA', 'KeyS', 'KeyD']) || testAnyButton([12,13,14,15]) || testAxis()) {\r\n        //     move.x = getCoordsFromAngle(angle).x * speed;\r\n        //     move.z = getCoordsFromAngle(angle).z * speed;\r\n        //     raycasterPosition.x += getCoordsFromAngle(angle).x * speed + horizontalOffset;\r\n        //     raycasterPosition.z += getCoordsFromAngle(angle).z * speed + horizontalOffset;\r\n        // }\r\n\r\n        // if(axis) {\r\n        //     angle = axis.angle + cameraAngle\r\n        //     move.x = axis.x * speed\r\n        //     move.z = axis.z * speed\r\n        //     raycasterPosition.x += axis.x * speed + (axis.x > 0? horizontalOffset : -horizontalOffset);\r\n        //     raycasterPosition.z += axis.z * speed + (axis.z > 0? horizontalOffset : -horizontalOffset);\r\n        // }\r\n\r\n        updateCameraPosition()\r\n        // const rotationRange = Math.abs(robotRotation - angle)\r\n        // if(oneLoop && rotationRange > 45 && rotationRange < 315) {\r\n        //     angle = robotRotation\r\n        //     move.x = 0\r\n        //     move.z = 0\r\n        // }\r\n\r\n        // Wykrywanie kolizji\r\n        // raycaster.set(raycasterPosition, new THREE.Vector3(0, -1, 0));\r\n        // const intersects = raycaster.intersectObject(objects['floor'], true);\r\n\r\n        // Pokazuje promienie raycastera\r\n        // const raycasterHelper = new THREE.ArrowHelper(raycaster.ray.direction, raycaster.ray.origin, robotHeight, 0xff00ff)\r\n        // scene.add(raycasterHelper);\r\n        // setTimeout(() => {scene.remove(raycasterHelper)}, 3000);\r\n\r\n        // Odległość od raycastera do najniższej części robota\r\n        //const rayToRobotDistance = Math.abs(skeletonExtremes.min.y - robotPosition.y)\r\n        // const rayToRobotDistanceHelper = new THREE.ArrowHelper(new Vector3(0, 1, 0), robotPosition, rayToRobotDistance, 0xff0000, 0, 0)\r\n        // rayToRobotDistanceHelper.renderOrder = 9999\r\n        // scene.add(rayToRobotDistanceHelper)\r\n        // setTimeout(() => {\r\n        //     scene.remove(rayToRobotDistanceHelper)\r\n        // }, 3000);\r\n\r\n        // Odległość od kolizji do pozycji Robota\r\n        //const collistionToRobotTop = intersects[0] ? intersects[0].distance - robotHeight : 0\r\n\r\n        // Sprawdza czy poruszamy sie w dół czy do góry\r\n        //const goUp = collistionToRobotTop >= 0 ? false : true\r\n\r\n        // if(intersects[0]) {\r\n        //     const collistionToRobotTopPosition = intersects[0].point.clone()\r\n        //     collistionToRobotTopPosition.x += 0.01\r\n        //     collistionToRobotTopPosition.z += 0.01\r\n        //     const collistionToRobotTopHelper = new THREE.ArrowHelper(new Vector3(0, goUp? -1 : 1, 0), collistionToRobotTopPosition, Math.abs(collistionToRobotTop), 0xffff00, 0, 0)\r\n        //     collistionToRobotTopHelper.renderOrder = 99999\r\n        //     scene.add(collistionToRobotTopHelper)\r\n        //     setTimeout(() => {\r\n        //         scene.remove(collistionToRobotTopHelper)\r\n        //     }, 3000);\r\n        // }\r\n\r\n        // if (intersects[0] && Math.abs(collistionToRobotTop) < distanceLimitUp + rayToRobotDistance && goUp) {\r\n        //     if(oneLoop) {\r\n        //         if(rayToRobotDistance >= Math.abs(collistionToRobotTop)) {\r\n        //             move.y = 0\r\n        //         } else {\r\n        //             if (oneLoopTrigger < Math.abs(collistionToRobotTop + rayToRobotDistance)) {\r\n        //                 move.y = Math.abs(collistionToRobotTop + rayToRobotDistance)\r\n        //                 if(currentAnimation) currentAnimation.warp(currentAnimation.timeScale, currentAnimation.timeScale*4, currentAnimation.getClip().duration-currentAnimation.time)\r\n        //             } else {\r\n        //                 move.y = 0\r\n        //             }\r\n        //         }\r\n\r\n        //         oneLoopTrigger = Math.abs(collistionToRobotTop + rayToRobotDistance)\r\n        //         return { move, angle };\r\n        //     } else {\r\n        //         oneLoopTrigger = 0\r\n        //         move.y = -intersects[0].distance + robotHeight;\r\n        //         return { move, angle };\r\n        //     }\r\n        // } else if(intersects[0] && collistionToRobotTop < distanceLimitDown && !goUp) {\r\n        //     move.y = -intersects[0].distance + robotHeight;\r\n        //     return { move, angle };\r\n        // } else {\r\n        //     move.x = 0;\r\n        //     move.y = 0;\r\n        //     move.z = 0;\r\n        //     return { move, angle};\r\n        // }\r\n    }\r\n\r\n    const robotRunning = () => {\r\n        if (mixers['Robot']) {\r\n            if (testAnyKeys(['KeyW', 'KeyA', 'KeyS', 'KeyD']) || testAnyButton([12,13,14,15]) || testAxis()) {\r\n                let acceleration = 1;\r\n                if (testAllKeys(['ShiftLeft']) || testAllButtons([7])) {\r\n                    acceleration = 2;\r\n                }\r\n                playAnimation(mixers['Robot'], animations['Robot'], 'Robot_Running', acceleration);\r\n            } else {\r\n                stopAnimation(mixers['Robot'], animations['Robot'], 'Robot_Running');\r\n            }\r\n\r\n            if (testAnyKeys(['Space']) || testAllButtons([0])) {\r\n                if(!pauseOthersAnimations) {\r\n                    //playAnimation(mixers['Robot'], animations['Robot'], 'Robot_Jump', 0.6, false);\r\n                    if(objects['Robot'].userData.velocity.y == 0) objects['Robot'].userData.velocity.y = 5;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    const toAnimate = () => {\r\n        for (const model in mixers) {\r\n            mixers[model].update(clock.getDelta());\r\n        }\r\n        if(objects['Robot'] && objects['collider']) checkKeysState()\r\n\r\n        // Jeżeli którykolwiek klawisz jest wciśnięty\r\n        if (Object.values(pressedKeys).includes(true) || pauseOthersAnimations || gamepads.value[0]) {\r\n            const keysStateResult = checkKeysState();\r\n            //objects['Robot'].position.add(keysStateResult.move);\r\n            //objects['Robot'].rotation.y = keysStateResult.angle * (Math.PI / 180);\r\n        }\r\n    }\r\n\r\n    const getSkeletonExtremes = (object: THREE.Object3D) => {\r\n        const skeleton = new THREE.SkeletonHelper(object)\r\n        const bone_min = new THREE.Vector3(Infinity,Infinity, Infinity);\r\n        const bone_max = new THREE.Vector3(-Infinity,-Infinity,-Infinity);\r\n\r\n        for(let b=0; b < skeleton.bones.length; b++){\r\n            const child = skeleton.bones[b];\r\n            const position = new THREE.Vector3();\r\n            child.getWorldPosition(position);\r\n\r\n            if(position.x < bone_min.x) bone_min.x = position.x\r\n            if(position.y < bone_min.y) bone_min.y = position.y\r\n            if(position.z < bone_min.z) bone_min.z = position.z\r\n\r\n            if(position.x > bone_max.x) bone_max.x = position.x\r\n            if(position.y > bone_max.y) bone_max.y = position.y\r\n            if(position.z > bone_max.z) bone_max.z = position.z\r\n        }\r\n\r\n        return {min: bone_min, max: bone_max}\r\n    }\r\n\r\n    onMounted( () => {\r\n        loader.load(\r\n            characterPath,\r\n            gltf => {\r\n                const model = gltf.scene;\r\n                model.traverse(child => {\r\n                    if (child instanceof THREE.Mesh) {\r\n                        child.castShadow = true;\r\n                        child.receiveShadow = true;\r\n                        child.material.shadowSide = 2;\r\n                    }\r\n                });\r\n\r\n                model.userData.name = 'Robot';\r\n                model.userData.isOnGround = false;\r\n                model.userData.velocity = new THREE.Vector3(0, 0, 0);\r\n                model.userData.speed = 1.5,\r\n                model.position.set(position.x, position.y, position.z);\r\n                scene.add(model);\r\n\r\n                //Zapisz dane obiektu\r\n                objects[model.userData.name] = model; // Obiekt\r\n                animations[model.userData.name] = gltf.animations; // Animacja\r\n                mixers[model.userData.name] = new THREE.AnimationMixer(model); // Mikser animacji\r\n                mixers[model.userData.name].addEventListener('finished', function(e: any) {\r\n                    pauseOthersAnimations = false;\r\n                    robotRunning()\r\n                    //console.log('animacja '+ e.action._clip.name +' skonczona');\r\n                });\r\n                animations[model.userData.name].forEach((animation: THREE.AnimationClip) => {\r\n                    mixers[model.userData.name].clipAction(animation).setEffectiveWeight(0).play()\r\n                });\r\n            },\r\n            undefined,\r\n            function(error) {\r\n                console.error(error);\r\n            },\r\n        );\r\n    });\r\n\r\n    return {\r\n        robotRunning,\r\n        toAnimate\r\n    }\r\n}","import { onUnmounted, ref, Ref } from 'vue';\r\n\r\nexport default function keysControls(pressedKeys: any) {\r\n\r\n    const keysFunctions: Array<any> = [];\r\n    const gamepads: Ref<(Gamepad | null)[]> = ref([]);\r\n\r\n    const keyUp = (e: any) => {\r\n        pressedKeys[e.code] = false;\r\n    }\r\n\r\n    const keyDown = (e: any) => {\r\n        pressedKeys[e.code] = true;\r\n    }\r\n\r\n    const connectGamepad = (e: any) => {\r\n        console.log(e.gamepad.id, 'podłączony')\r\n    }\r\n\r\n    const disconectGamepad = (e: any) => {\r\n        console.log(e.gamepad.id, 'odłączony')\r\n    }\r\n\r\n    const checkPads = () => {\r\n        gamepads.value = navigator.getGamepads()\r\n    }\r\n\r\n    const checkPressedKeys = () => {\r\n        keysFunctions.forEach(func => { func() });\r\n    }\r\n\r\n    window.addEventListener('keydown', keyDown);\r\n    window.addEventListener('keyup', keyUp);\r\n    window.addEventListener(\"gamepadconnected\", connectGamepad);\r\n    window.addEventListener(\"gamepaddisconnected\", disconectGamepad)\r\n\r\n    const testAllKeys = (keysArray: any, exceptionKeysArray: any = null) => {\r\n        const activeInArray = keysArray.every((e: any) => pressedKeys[e] === true); // Czy klawisze z listy są wciąnięte\r\n        if (exceptionKeysArray) {\r\n            const exceptionInArray = exceptionKeysArray.every((e: any) => pressedKeys[e] === false || pressedKeys[e] === undefined);\r\n            return activeInArray && exceptionInArray;\r\n        }\r\n        return activeInArray;\r\n    };\r\n\r\n    const testAnyKeys = (keysArray: any) => {\r\n        return keysArray.some((e: any) => pressedKeys[e] === true);\r\n    };\r\n\r\n    const testAllButtons = (buttonsArray: any, exceptionKeysArray: any = null) => {\r\n        const activeInArray = buttonsArray.every((button: any) => gamepads.value[0]?.buttons[button].pressed)\r\n        if (exceptionKeysArray) {\r\n            const exceptionInArray = exceptionKeysArray.every((button: any) => !gamepads.value[0]?.buttons[button].pressed);\r\n            return activeInArray && exceptionInArray;\r\n        }\r\n        return activeInArray;\r\n    }\r\n\r\n    const testAxis = () => {\r\n        if(gamepads.value[0]) {\r\n            const axisTolerance = 0.3\r\n            const a0 = gamepads.value[0]?.axes[0] \r\n            const a1 = gamepads.value[0]?.axes[1]\r\n            const angle = Math.atan2(a1, -a0) * 180 / Math.PI;\r\n\r\n            const result = {\r\n                angle: angle - 90,\r\n                x: a0,\r\n                z: a1\r\n            }\r\n\r\n            if(Math.abs(a0) > axisTolerance || Math.abs(a1) > axisTolerance) return result\r\n        }\r\n    }\r\n\r\n    const testAnyButton = (buttonsArray: any) => {\r\n        return buttonsArray.some((button: any) => gamepads.value[0]?.buttons[button].pressed);\r\n    };\r\n\r\n    onUnmounted(() => {\r\n        window.removeEventListener('keydown', keyDown);\r\n        window.removeEventListener('keyup', keyUp);\r\n        window.removeEventListener(\"gamepadconnected\", connectGamepad);\r\n        window.addEventListener(\"gamepaddisconnected\", disconectGamepad)\r\n    })\r\n\r\n    return {\r\n        testAllKeys,\r\n        testAnyKeys,\r\n        keysFunctions,\r\n        checkPressedKeys,\r\n        testAllButtons,\r\n        testAnyButton,\r\n        testAxis,\r\n        checkPads,\r\n        gamepads\r\n    }\r\n}\r\n","import { onMounted, reactive } from 'vue';\r\nimport * as THREE from 'three';\r\n\r\n\r\nexport default function addLoaderManager(manager: THREE.LoadingManager) {\r\n    const loading = reactive({\r\n        loaded: 0,\r\n        total: 0,\r\n        progress: 0,\r\n    })\r\n\r\n    onMounted( () => {\r\n        manager.onProgress = (item, loaded, total) => {\r\n            loading.loaded = loaded;\r\n            loading.total = total;\r\n            loading.progress = Math.round((loaded / total) * 10000) / 100;\r\n        };\r\n    })\r\n\r\n    return {\r\n        loading\r\n    };\r\n}","\r\nimport * as THREE from 'three';\r\nimport createScene from '../hooks/createScene';\r\nimport addLights from '../hooks/addLights';\r\nimport postProduction from '../hooks/postProduction';\r\nimport addMap from '../hooks/addMap';\r\nimport addCharacter from '../hooks/addCharacter';\r\nimport keysControls from '../hooks/keysControls';\r\nimport addLoaderManager from '../hooks/addLoaderManager';\r\nimport { publicPath } from '../../vue.config';\r\n\r\nimport { ref } from 'vue';\r\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\r\nimport { Vector3 } from 'three';\r\n\r\n//import * as dat from 'dat.gui';\r\n\r\nexport default {\r\n    setup() {\r\n        const popup = ref(false);\r\n\r\n        //const gui = new dat.GUI();\r\n        // Zmienne sceny\r\n        // const characterPosition = new Vector3(5, 11.5, 0);\r\n        const characterPosition = new Vector3(0, 0, 0);\r\n        //const cameraOffset = new Vector3(5, 30, 50); // wektor przesunięcia kamery względem postaci\r\n        const cameraOffset = new Vector3(2.5, 15, 25);\r\n        // const cameraOffset = new Vector3(-35, 15, 15);\r\n\r\n        // Dodaj scenę\r\n        const sceneRef = ref(null);\r\n        const { scene, renderer, camera, animateFunctions, animation, controls } = createScene(sceneRef, characterPosition, cameraOffset);\r\n\r\n        // Dodaj światła\r\n        addLights(scene);\r\n\r\n        // Dodaj postprodukcję\r\n        postProduction(scene, camera, renderer)\r\n\r\n        // Dodaj manager ładowania\r\n        const manager = new THREE.LoadingManager();\r\n        const { loading } = addLoaderManager(manager)\r\n\r\n        // Załaduj główną mapę\r\n        const loader = new GLTFLoader(manager);\r\n        const objects: any = {};\r\n        // addMap(loader, scene, objects, `${publicPath}peach_castle/scene.gltf`, `${publicPath}peach_castle/floor.gltf`);\r\n        addMap(loader, scene, objects, `${publicPath}islands/islands.gltf`, `${publicPath}islands/islands_physics.gltf`);\r\n\r\n        // Wczytaj funkcje obsługi klawiszy i padów\r\n        const pressedKeys: any = {};\r\n\r\n        const { testAllKeys, testAnyKeys, keysFunctions, checkPressedKeys, testAllButtons, testAnyButton, testAxis, checkPads, gamepads} = keysControls(pressedKeys);\r\n        animateFunctions.push(checkPressedKeys, checkPads)\r\n\r\n        // Wczytaj postać z funkcjami ruchu i animacji\r\n        const animations: any = {};\r\n        const mixers: any = {};\r\n        const { robotRunning, toAnimate } = addCharacter(\r\n            loader, scene, objects, animations, mixers,\r\n            pressedKeys, testAllKeys, testAnyKeys,\r\n            gamepads, testAllButtons, testAnyButton, testAxis, `${publicPath}Robot_edited_centered.glb`,\r\n            controls, camera, characterPosition, cameraOffset, animation\r\n        );\r\n        animateFunctions.push(toAnimate);\r\n        keysFunctions.push(robotRunning);\r\n\r\n        return {\r\n            sceneRef,\r\n            loading,\r\n            popup,\r\n            close,\r\n            camera,\r\n            animations,\r\n            mixers\r\n        }\r\n    }\r\n}\r\n","import { render } from \"./NewScene.vue?vue&type=template&id=44fd9147&scoped=true\"\nimport script from \"./NewScene.vue?vue&type=script&lang=ts\"\nexport * from \"./NewScene.vue?vue&type=script&lang=ts\"\n\nimport \"./NewScene.vue?vue&type=style&index=0&id=44fd9147&scoped=true&lang=scss\"\nscript.render = render\nscript.__scopeId = \"data-v-44fd9147\"\n\nexport default script","\r\nimport { Options, Vue } from 'vue-class-component';\r\nimport Scene from '../components/Scene.vue';\r\nimport NewScene from '../components/NewScene.vue';\r\n\r\n@Options({\r\n    components: {\r\n        Scene, NewScene\r\n    },\r\n})\r\nexport default class App extends Vue {}\r\n","import { render } from \"./Home.vue?vue&type=template&id=c1e5622a\"\nimport script from \"./Home.vue?vue&type=script&lang=ts\"\nexport * from \"./Home.vue?vue&type=script&lang=ts\"\nscript.render = render\n\nexport default script","import { createRouter, createWebHistory, RouteRecordRaw } from 'vue-router'\nimport Home from '../views/Home.vue'\n\nconst routes: Array<RouteRecordRaw> = [\n    {\n        path: '/',\n        name: 'Home',\n        component: Home\n    }\n]\n\nconst router = createRouter({\n    history: createWebHistory(process.env.BASE_URL),\n    routes\n})\n\nexport default router\n","import { createStore } from 'vuex'\n\nexport default createStore({\n    state: {\n    },\n    mutations: {\n    },\n    actions: {\n    },\n    modules: {\n    }\n})\n","import { createApp } from 'vue'\r\nimport App from './App.vue'\r\nimport router from './router'\r\nimport store from './store'\r\n\r\ncreateApp(App).use(store).use(router).mount('#app')\r\n","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader-v16/dist/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader-v16/dist/index.js??ref--0-1!./NewScene.vue?vue&type=style&index=0&id=44fd9147&scoped=true&lang=scss\""],"sourceRoot":""}