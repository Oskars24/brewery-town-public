{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/components/Scene.vue?7a67","webpack:///./src/components/NewScene.vue?a03f","webpack:///./src/App.vue?79d3","webpack:///./src/App.vue","webpack:///./src/App.vue?dfb6","webpack:///./src/views/Home.vue","webpack:///./src/components/Scene.vue","webpack:///./src/components/Scene.vue?87b2","webpack:///./src/components/Scene.vue?53da","webpack:///./src/components/NewScene.vue","webpack:///./src/hooks/createScene.ts","webpack:///./src/hooks/addLights.ts","webpack:///./src/hooks/postProduction.ts","webpack:///./src/hooks/addMap.ts","webpack:///./src/hooks/addCharacter.ts","webpack:///./src/hooks/keysControls.ts","webpack:///./src/components/NewScene.vue?7ae4","webpack:///./src/components/NewScene.vue?4af3","webpack:///./src/views/Home.vue?d5e7","webpack:///./src/views/Home.vue?ab8c","webpack:///./src/router/index.ts","webpack:///./src/store/index.ts","webpack:///./src/main.ts"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","id","script","render","class","ref","setup","camera","renderer","antialias","scene","clock","raycaster","objects","mixers","animations","pressedKeys","sceneRef","playAnimation","objectMixer","objectAnimations","animationName","acceleration","loop","weight","clip","find","el","animation","clipAction","timeScale","isPlaying","setTimeout","duration","setEffectiveWeight","play","setLoop","reset","setEffectiveTimeScale","stopAnimation","stop","testAllKeys","keysArray","exceptionKeysArray","activeInArray","every","e","exceptionInArray","undefined","testAnyKeys","some","checkKeysState","robotPosition","position","x","y","z","positionOffset","speed","distanceLimit","angle","move","set","intersects","intersectObject","distance","robotRunning","keyUp","code","keyDown","addEventListener","mixer","clientWidth","clientHeight","setSize","appendChild","domElement","loader","GLTFLoader","load","gltf","model","add","error","console","userData","forEach","action","_clip","log","visible","ambientLight","mainLight","controls","OrbitControls","enableDamping","dampingFactor","screenSpacePanning","minDistance","maxDistance","composer","EffectComposer","renderPass","RenderPass","addPass","pass","SMAAPass","innerWidth","getPixelRatio","innerHeight","animate","requestAnimationFrame","update","getDelta","values","includes","keysStateResult","rotation","Math","PI","removeEventListener","__scopeId","createScene","characterPosition","cameraOffset","animateFunctions","onWindowResize","aspect","updateProjectionMatrix","setPixelRatio","min","devicePixelRatio","fov","near","far","stats","showPanel","document","body","dom","enablePan","enableRotate","enableZoom","target","begin","func","end","addLights","postProduction","addMap","mapPath","collisionMapPath","addCharacter","gamepads","testAllButtons","testAnyButton","testAxis","characterPath","pauseOthersAnimations","currentAnimation","oneLoopTrigger","time","getClip","fadeOut","getFadeTime","fadeIn","startAnimation","endAnimation","startAnimationTime","getEffectiveTimeScale","endAnimationTime","updateCameraPosition","targets","easing","complete","clone","robotRotation","skeletonExtremes","getSkeletonExtremes","robotHeight","max","raycasterPosition","horizontalOffset","distanceLimitUp","distanceLimitDown","oneLoop","axis","rotationRange","abs","rayToRobotDistance","collistionToRobotTop","goUp","warp","toAnimate","skeleton","bone_min","Infinity","bone_max","b","bones","child","getWorldPosition","keysControls","keysFunctions","connectGamepad","gamepad","disconectGamepad","checkPads","navigator","getGamepads","checkPressedKeys","buttonsArray","button","buttons","pressed","axisTolerance","a0","axes","a1","atan2","components","Scene","NewScene","routes","path","component","Home","router","history","state","mutations","actions","use","store","mount"],"mappings":"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","file":"js/app.872857e9.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t\"app\": 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([0,\"chunk-vendors\"]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader-v16/dist/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader-v16/dist/index.js??ref--0-1!./Scene.vue?vue&type=style&index=0&id=549912f1&scoped=true&lang=scss\"","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader-v16/dist/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader-v16/dist/index.js??ref--0-1!./NewScene.vue?vue&type=style&index=0&id=4d3d209c&scoped=true&lang=scss\"","export * from \"-!../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../node_modules/vue-loader-v16/dist/stylePostLoader.js!../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader-v16/dist/index.js??ref--0-1!./App.vue?vue&type=style&index=0&id=b75d6652&lang=scss\"","<template>\n    <div id=\"app\">\n        <router-view />\n    </div>\n</template>\n\n<style lang=\"scss\">\nbody {\n    margin: 0;\n}\n#app {\n    font-family: Avenir, Helvetica, Arial, sans-serif;\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n    text-align: center;\n    color: #2c3e50;\n}\n\n#nav {\n    padding: 30px;\n\n    a {\n        font-weight: bold;\n        color: #2c3e50;\n\n        &.router-link-exact-active {\n            color: #42b983;\n        }\n    }\n}\n</style>\n","import { render } from \"./App.vue?vue&type=template&id=b75d6652\"\nconst script = {}\n\nimport \"./App.vue?vue&type=style&index=0&id=b75d6652&lang=scss\"\nscript.render = render\n\nexport default script","<template>\n    <div>\n        <!-- <Scene /> -->\n        <new-scene/>\n    </div>\n</template>\n\n<script lang=\"ts\">\nimport { Options, Vue } from 'vue-class-component';\nimport Scene from '../components/Scene.vue';\nimport NewScene from '../components/NewScene.vue';\n\n@Options({\n    components: {\n        Scene, NewScene\n    },\n})\nexport default class App extends Vue {}\n</script>\n","<template v-cloak>\r\n    <div class=\"container\">\r\n        <div class=\"scene\" ref=\"sceneRef\"></div>\r\n    </div>\r\n</template>\r\n\r\n<script lang=\"ts\">\r\n//import { Options, Vue } from 'vue-class-component';\r\nimport * as THREE from 'three';\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\r\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\r\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';\r\nimport { SMAAPass } from 'three/examples/jsm/postprocessing/SMAAPass.js';\r\n\r\nimport { ref, onMounted, onUnmounted } from 'vue'\r\n\r\nexport default {\r\n    setup() {\r\n        let camera!: THREE.PerspectiveCamera\r\n        const renderer: THREE.WebGLRenderer = new THREE.WebGLRenderer({ antialias: true });\r\n        const scene: THREE.Scene = new THREE.Scene();\r\n        const clock = new THREE.Clock();\r\n        const raycaster = new THREE.Raycaster();\r\n        const objects: any = {};\r\n        const mixers: any = {};\r\n        const animations: any = {};\r\n        const pressedKeys: any = {};\r\n        const sceneRef = ref(null);\r\n\r\n        const playAnimation = (objectMixer: any, objectAnimations: any, animationName: any, acceleration = 1, loop = true, weight = 1) => {\r\n            const clip = objectAnimations.find((el: any) => el.name === animationName);\r\n            const animation = objectMixer.clipAction(clip);\r\n            animation.timeScale = acceleration;\r\n            if (animations['Robot'][2].isPlaying) {\r\n                weight = 0;\r\n                setTimeout(() => {\r\n                    playAnimation(objectMixer, objectAnimations, animationName, acceleration, true, 1);\r\n                }, animations['Robot'][2].duration * 1000);\r\n            }\r\n            clip.isPlaying = true;\r\n            if (!loop) {\r\n                animation.setLoop(THREE.LoopOnce);\r\n                animation\r\n                    .reset()\r\n                    .setEffectiveTimeScale(0.5)\r\n                    .setEffectiveWeight(1) // wykombinować to ustawienie dla wszystkich animacji łączonych\r\n                    .play();\r\n            } else {\r\n                animation.setEffectiveWeight(weight).play();\r\n            }\r\n        }\r\n\r\n        const stopAnimation = (objectMixer: any, objectAnimations: any, animationName: any) => {\r\n            const clip = objectAnimations.find((el: any) => el.name === animationName);\r\n            const animation = objectMixer.clipAction(clip);\r\n            animation.stop();\r\n        }\r\n\r\n        const testAllKeys = (keysArray: any, exceptionKeysArray: any = null) => {\r\n            const activeInArray = keysArray.every((e: any) => pressedKeys[e] === true); // Czy klawisze z listy są wciąnięte\r\n            if (exceptionKeysArray) {\r\n                const exceptionInArray = exceptionKeysArray.every((e: any) => pressedKeys[e] === false || pressedKeys[e] === undefined);\r\n                return activeInArray && exceptionInArray;\r\n            }\r\n            return activeInArray;\r\n        };\r\n\r\n        const testAnyKeys = (keysArray: any) => {\r\n            return keysArray.some((e: any) => pressedKeys[e] === true);\r\n        };\r\n\r\n        const checkKeysState = () => {\r\n            const robotPosition = new THREE.Vector3(objects['Robot'].position.x, objects['Robot'].position.y, objects['Robot'].position.z);\r\n            const positionOffset = 5; // największa wysokość na jaką może wejść\r\n            robotPosition.y += positionOffset;\r\n            let speed = 0.18;\r\n            const distanceLimit = 6; // limit wielkości na jaką może wejść/zejść\r\n            let angle = 0;\r\n            const move = new THREE.Vector3();\r\n\r\n            if (testAllKeys(['ShiftLeft'])) {\r\n                speed *= 2;\r\n            }\r\n\r\n            if (testAllKeys(['KeyW'], ['KeyA', 'KeyS', 'KeyD'])) {\r\n                angle = 180;\r\n                move.z = -1 * speed;\r\n                robotPosition.z += -1 * speed;\r\n            } else if (testAllKeys(['KeyA'], ['KeyW', 'KeyS', 'KeyD'])) {\r\n                angle = -90;\r\n                move.x = -1 * speed;\r\n                robotPosition.x += -1 * speed;\r\n            } else if (testAllKeys(['KeyS'], ['KeyW', 'KeyA', 'KeyD'])) {\r\n                angle = 0;\r\n                move.z = 1 * speed;\r\n                robotPosition.z += 1 * speed;\r\n            } else if (testAllKeys(['KeyD'], ['KeyW', 'KeyA', 'KeyS'])) {\r\n                angle = 90;\r\n                move.x = 1 * speed;\r\n                robotPosition.x += 1 * speed;\r\n            } else if (testAllKeys(['KeyW', 'KeyA'])) {\r\n                angle = -135;\r\n                move.x = -1 * speed;\r\n                move.z = -1 * speed;\r\n                robotPosition.x += -1 * speed;\r\n                robotPosition.z += -1 * speed;\r\n            } else if (testAllKeys(['KeyW', 'KeyD'])) {\r\n                angle = 135;\r\n                move.x = 1 * speed;\r\n                move.z = -1 * speed;\r\n                robotPosition.x += 1 * speed;\r\n                robotPosition.z += -1 * speed;\r\n            } else if (testAllKeys(['KeyS', 'KeyA'])) {\r\n                angle = -45;\r\n                move.x = -1 * speed;\r\n                move.z = 1 * speed;\r\n                robotPosition.x += -1 * speed;\r\n                robotPosition.z += 1 * speed;\r\n            } else if (testAllKeys(['KeyS', 'KeyD'])) {\r\n                angle = 45;\r\n                move.x = 1 * speed;\r\n                move.z = 1 * speed;\r\n                robotPosition.x += 1 * speed;\r\n                robotPosition.z += 1 * speed;\r\n            }\r\n\r\n            // Wykrywanie kolizji\r\n            raycaster.set(robotPosition, new THREE.Vector3(0, -1, 0));\r\n            const intersects = raycaster.intersectObject(objects['floor'], true);\r\n\r\n            // Pokazuje promienie raycastera\r\n            //this.scene.add(new THREE.ArrowHelper(this.raycaster.ray.direction, this.raycaster.ray.origin, positionOffset, 0xff0000));\r\n\r\n            if (intersects[0] && intersects[0].distance - positionOffset < distanceLimit) {\r\n                move.y = -intersects[0].distance + positionOffset;\r\n                return { move, angle };\r\n            } else {\r\n                move.x = 0;\r\n                move.y = 0;\r\n                move.z = 0;\r\n                return { move, angle };\r\n            }\r\n        }\r\n\r\n        const robotRunning = () => {\r\n            if (mixers['Robot']) {\r\n                if (testAnyKeys(['KeyW', 'KeyA', 'KeyS', 'KeyD'])) {\r\n                    let acceleration = 1;\r\n                    if (testAllKeys(['ShiftLeft'])) {\r\n                        acceleration = 2;\r\n                    }\r\n                    playAnimation(mixers['Robot'], animations['Robot'], 'Robot_Running', acceleration);\r\n                } else {\r\n                    stopAnimation(mixers['Robot'], animations['Robot'], 'Robot_Running');\r\n                }\r\n\r\n                if (testAnyKeys(['Space'])) {\r\n                    playAnimation(mixers['Robot'], animations['Robot'], 'Robot_Jump', 1, false);\r\n                }\r\n            }\r\n        }\r\n\r\n        const keyUp = (e: any) => {\r\n            pressedKeys[e.code] = false;\r\n            robotRunning();\r\n        }\r\n\r\n        const keyDown = (e: any) => {\r\n            pressedKeys[e.code] = true;\r\n            robotRunning();\r\n        }\r\n\r\n        //Created\r\n        window.addEventListener('keydown', keyDown);\r\n        window.addEventListener('keyup', keyUp);\r\n\r\n        onMounted(() => {\r\n            const el = sceneRef.value as any;\r\n            camera = new THREE.PerspectiveCamera(60, el.clientWidth / el.clientHeight, 1, 1000);\r\n            camera.position.set(55, 55, 55);\r\n            renderer.setSize(el.clientWidth, el.clientHeight);\r\n            el.appendChild(renderer.domElement);\r\n\r\n            // Dodanie loadera plików\r\n            let mixer: any;\r\n            const loader = new GLTFLoader();\r\n\r\n            loader.load(\r\n                '/peach_castle/scene.gltf',\r\n                gltf => {\r\n                    const model = gltf.scene;\r\n                    scene.add(model);\r\n\r\n                    //Animacja\r\n                    if (gltf.animations.length) {\r\n                        mixer = new THREE.AnimationMixer(model);\r\n                        mixer.clipAction(gltf.animations[0]).play();\r\n                    }\r\n                },\r\n                undefined,\r\n                function(error) {\r\n                    console.error(error);\r\n                },\r\n            );\r\n\r\n            loader.load(\r\n                '/Robot.gltf',\r\n                gltf => {\r\n                    const model = gltf.scene;\r\n                    model.userData.name = 'Robot';\r\n                    scene.add(model);\r\n                    model.position.set(5, 12, 0);\r\n\r\n                    //Zapisz dane obiektu\r\n                    objects[model.userData.name] = model; // Obiekt\r\n                    animations[model.userData.name] = gltf.animations; // Animacja\r\n                    animations[model.userData.name].forEach((e: any) => {\r\n                        e.isPlaying = false;\r\n                    });\r\n                    mixers[model.userData.name] = new THREE.AnimationMixer(model); // Mikser animacji\r\n                    mixers[model.userData.name].addEventListener('finished', function(e: any) {\r\n                        e.action._clip.isPlaying = false;\r\n                        console.log('animacja skonczona');\r\n                    });\r\n                },\r\n                undefined,\r\n                function(error) {\r\n                    console.error(error);\r\n                },\r\n            );\r\n\r\n            loader.load(\r\n                '/peach_castle/floor.gltf',\r\n                gltf => {\r\n                    const model = gltf.scene;\r\n                    model.userData.name = 'floor';\r\n                    model.visible = false;\r\n                    scene.add(model);\r\n\r\n                    //Zapisz dane obiektu\r\n                    objects[model.userData.name] = model; // Obiekt\r\n                },\r\n                undefined,\r\n                function(error) {\r\n                    console.error(error);\r\n                },\r\n            );\r\n\r\n            // Dodanie światła\r\n            const ambientLight = new THREE.HemisphereLight(0xffffff, 0x222222, 1);\r\n            const mainLight = new THREE.DirectionalLight(0xffffff, 4.0);\r\n            mainLight.position.set(10, 10, 10);\r\n            scene.add(ambientLight, mainLight);\r\n\r\n            // Sterowanie kamera za pomoca myszy\r\n            const controls = new OrbitControls(camera, renderer.domElement);\r\n            controls.enableDamping = true;\r\n            controls.dampingFactor = 0.05;\r\n            controls.screenSpacePanning = false;\r\n            controls.minDistance = 10;\r\n            controls.maxDistance = 500;\r\n\r\n            // Postprocessing\r\n            const composer = new EffectComposer(renderer);\r\n            const renderPass = new RenderPass(scene, camera);\r\n            composer.addPass(renderPass);\r\n            const pass = new SMAAPass(window.innerWidth * renderer.getPixelRatio(), window.innerHeight * renderer.getPixelRatio());\r\n            composer.addPass(pass);\r\n\r\n            // Funkcja renderująca\r\n            const render = () => {\r\n                renderer.render(scene, camera);\r\n            };\r\n\r\n            // Główna pętla animacji\r\n            const animate = () => {\r\n                requestAnimationFrame(animate);\r\n\r\n                if (typeof mixer !== 'undefined') {\r\n                    mixer.update(clock.getDelta());\r\n                }\r\n\r\n                for (const model in mixers) {\r\n                    mixers[model].update(clock.getDelta());\r\n                }\r\n\r\n                // Jeżeli którykolwiek klawisz jest wciśnięty\r\n                if (Object.values(pressedKeys).includes(true)) {\r\n                    const keysStateResult = checkKeysState();\r\n                    objects['Robot'].position.add(keysStateResult.move);\r\n                    objects['Robot'].rotation.y = keysStateResult.angle * (Math.PI / 180);\r\n                }\r\n\r\n                controls.update();\r\n                //composer.render(); // Render postprocessingu\r\n                render(); // Render standardowy\r\n            };\r\n\r\n            animate();\r\n        })\r\n\r\n        onUnmounted(() => {\r\n            window.removeEventListener('keydown', keyDown);\r\n            window.removeEventListener('keyup', keyUp);\r\n        })\r\n\r\n        return {camera, renderer, scene, clock, raycaster, objects, mixers, animations, pressedKeys, sceneRef, playAnimation, stopAnimation, testAllKeys, testAnyKeys, checkKeysState, robotRunning, keyUp, keyDown}\r\n    }\r\n}\r\n</script>\r\n\r\n<style scoped lang=\"scss\">\r\n.scene {\r\n    width: 100vw;\r\n    height: 100vh;\r\n}\r\n\r\n.info {\r\n    z-index: 999;\r\n    background-color: white;\r\n    border: 1px solid black;\r\n    position: absolute;\r\n    right: 0;\r\n    top: 0;\r\n    text-align: left;\r\n}\r\n</style>\r\n","\r\n//import { Options, Vue } from 'vue-class-component';\r\nimport * as THREE from 'three';\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\r\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\r\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';\r\nimport { SMAAPass } from 'three/examples/jsm/postprocessing/SMAAPass.js';\r\n\r\nimport { ref, onMounted, onUnmounted } from 'vue'\r\n\r\nexport default {\r\n    setup() {\r\n        let camera!: THREE.PerspectiveCamera\r\n        const renderer: THREE.WebGLRenderer = new THREE.WebGLRenderer({ antialias: true });\r\n        const scene: THREE.Scene = new THREE.Scene();\r\n        const clock = new THREE.Clock();\r\n        const raycaster = new THREE.Raycaster();\r\n        const objects: any = {};\r\n        const mixers: any = {};\r\n        const animations: any = {};\r\n        const pressedKeys: any = {};\r\n        const sceneRef = ref(null);\r\n\r\n        const playAnimation = (objectMixer: any, objectAnimations: any, animationName: any, acceleration = 1, loop = true, weight = 1) => {\r\n            const clip = objectAnimations.find((el: any) => el.name === animationName);\r\n            const animation = objectMixer.clipAction(clip);\r\n            animation.timeScale = acceleration;\r\n            if (animations['Robot'][2].isPlaying) {\r\n                weight = 0;\r\n                setTimeout(() => {\r\n                    playAnimation(objectMixer, objectAnimations, animationName, acceleration, true, 1);\r\n                }, animations['Robot'][2].duration * 1000);\r\n            }\r\n            clip.isPlaying = true;\r\n            if (!loop) {\r\n                animation.setLoop(THREE.LoopOnce);\r\n                animation\r\n                    .reset()\r\n                    .setEffectiveTimeScale(0.5)\r\n                    .setEffectiveWeight(1) // wykombinować to ustawienie dla wszystkich animacji łączonych\r\n                    .play();\r\n            } else {\r\n                animation.setEffectiveWeight(weight).play();\r\n            }\r\n        }\r\n\r\n        const stopAnimation = (objectMixer: any, objectAnimations: any, animationName: any) => {\r\n            const clip = objectAnimations.find((el: any) => el.name === animationName);\r\n            const animation = objectMixer.clipAction(clip);\r\n            animation.stop();\r\n        }\r\n\r\n        const testAllKeys = (keysArray: any, exceptionKeysArray: any = null) => {\r\n            const activeInArray = keysArray.every((e: any) => pressedKeys[e] === true); // Czy klawisze z listy są wciąnięte\r\n            if (exceptionKeysArray) {\r\n                const exceptionInArray = exceptionKeysArray.every((e: any) => pressedKeys[e] === false || pressedKeys[e] === undefined);\r\n                return activeInArray && exceptionInArray;\r\n            }\r\n            return activeInArray;\r\n        };\r\n\r\n        const testAnyKeys = (keysArray: any) => {\r\n            return keysArray.some((e: any) => pressedKeys[e] === true);\r\n        };\r\n\r\n        const checkKeysState = () => {\r\n            const robotPosition = new THREE.Vector3(objects['Robot'].position.x, objects['Robot'].position.y, objects['Robot'].position.z);\r\n            const positionOffset = 5; // największa wysokość na jaką może wejść\r\n            robotPosition.y += positionOffset;\r\n            let speed = 0.18;\r\n            const distanceLimit = 6; // limit wielkości na jaką może wejść/zejść\r\n            let angle = 0;\r\n            const move = new THREE.Vector3();\r\n\r\n            if (testAllKeys(['ShiftLeft'])) {\r\n                speed *= 2;\r\n            }\r\n\r\n            if (testAllKeys(['KeyW'], ['KeyA', 'KeyS', 'KeyD'])) {\r\n                angle = 180;\r\n                move.z = -1 * speed;\r\n                robotPosition.z += -1 * speed;\r\n            } else if (testAllKeys(['KeyA'], ['KeyW', 'KeyS', 'KeyD'])) {\r\n                angle = -90;\r\n                move.x = -1 * speed;\r\n                robotPosition.x += -1 * speed;\r\n            } else if (testAllKeys(['KeyS'], ['KeyW', 'KeyA', 'KeyD'])) {\r\n                angle = 0;\r\n                move.z = 1 * speed;\r\n                robotPosition.z += 1 * speed;\r\n            } else if (testAllKeys(['KeyD'], ['KeyW', 'KeyA', 'KeyS'])) {\r\n                angle = 90;\r\n                move.x = 1 * speed;\r\n                robotPosition.x += 1 * speed;\r\n            } else if (testAllKeys(['KeyW', 'KeyA'])) {\r\n                angle = -135;\r\n                move.x = -1 * speed;\r\n                move.z = -1 * speed;\r\n                robotPosition.x += -1 * speed;\r\n                robotPosition.z += -1 * speed;\r\n            } else if (testAllKeys(['KeyW', 'KeyD'])) {\r\n                angle = 135;\r\n                move.x = 1 * speed;\r\n                move.z = -1 * speed;\r\n                robotPosition.x += 1 * speed;\r\n                robotPosition.z += -1 * speed;\r\n            } else if (testAllKeys(['KeyS', 'KeyA'])) {\r\n                angle = -45;\r\n                move.x = -1 * speed;\r\n                move.z = 1 * speed;\r\n                robotPosition.x += -1 * speed;\r\n                robotPosition.z += 1 * speed;\r\n            } else if (testAllKeys(['KeyS', 'KeyD'])) {\r\n                angle = 45;\r\n                move.x = 1 * speed;\r\n                move.z = 1 * speed;\r\n                robotPosition.x += 1 * speed;\r\n                robotPosition.z += 1 * speed;\r\n            }\r\n\r\n            // Wykrywanie kolizji\r\n            raycaster.set(robotPosition, new THREE.Vector3(0, -1, 0));\r\n            const intersects = raycaster.intersectObject(objects['floor'], true);\r\n\r\n            // Pokazuje promienie raycastera\r\n            //this.scene.add(new THREE.ArrowHelper(this.raycaster.ray.direction, this.raycaster.ray.origin, positionOffset, 0xff0000));\r\n\r\n            if (intersects[0] && intersects[0].distance - positionOffset < distanceLimit) {\r\n                move.y = -intersects[0].distance + positionOffset;\r\n                return { move, angle };\r\n            } else {\r\n                move.x = 0;\r\n                move.y = 0;\r\n                move.z = 0;\r\n                return { move, angle };\r\n            }\r\n        }\r\n\r\n        const robotRunning = () => {\r\n            if (mixers['Robot']) {\r\n                if (testAnyKeys(['KeyW', 'KeyA', 'KeyS', 'KeyD'])) {\r\n                    let acceleration = 1;\r\n                    if (testAllKeys(['ShiftLeft'])) {\r\n                        acceleration = 2;\r\n                    }\r\n                    playAnimation(mixers['Robot'], animations['Robot'], 'Robot_Running', acceleration);\r\n                } else {\r\n                    stopAnimation(mixers['Robot'], animations['Robot'], 'Robot_Running');\r\n                }\r\n\r\n                if (testAnyKeys(['Space'])) {\r\n                    playAnimation(mixers['Robot'], animations['Robot'], 'Robot_Jump', 1, false);\r\n                }\r\n            }\r\n        }\r\n\r\n        const keyUp = (e: any) => {\r\n            pressedKeys[e.code] = false;\r\n            robotRunning();\r\n        }\r\n\r\n        const keyDown = (e: any) => {\r\n            pressedKeys[e.code] = true;\r\n            robotRunning();\r\n        }\r\n\r\n        //Created\r\n        window.addEventListener('keydown', keyDown);\r\n        window.addEventListener('keyup', keyUp);\r\n\r\n        onMounted(() => {\r\n            const el = sceneRef.value as any;\r\n            camera = new THREE.PerspectiveCamera(60, el.clientWidth / el.clientHeight, 1, 1000);\r\n            camera.position.set(55, 55, 55);\r\n            renderer.setSize(el.clientWidth, el.clientHeight);\r\n            el.appendChild(renderer.domElement);\r\n\r\n            // Dodanie loadera plików\r\n            let mixer: any;\r\n            const loader = new GLTFLoader();\r\n\r\n            loader.load(\r\n                '/peach_castle/scene.gltf',\r\n                gltf => {\r\n                    const model = gltf.scene;\r\n                    scene.add(model);\r\n\r\n                    //Animacja\r\n                    if (gltf.animations.length) {\r\n                        mixer = new THREE.AnimationMixer(model);\r\n                        mixer.clipAction(gltf.animations[0]).play();\r\n                    }\r\n                },\r\n                undefined,\r\n                function(error) {\r\n                    console.error(error);\r\n                },\r\n            );\r\n\r\n            loader.load(\r\n                '/Robot.gltf',\r\n                gltf => {\r\n                    const model = gltf.scene;\r\n                    model.userData.name = 'Robot';\r\n                    scene.add(model);\r\n                    model.position.set(5, 12, 0);\r\n\r\n                    //Zapisz dane obiektu\r\n                    objects[model.userData.name] = model; // Obiekt\r\n                    animations[model.userData.name] = gltf.animations; // Animacja\r\n                    animations[model.userData.name].forEach((e: any) => {\r\n                        e.isPlaying = false;\r\n                    });\r\n                    mixers[model.userData.name] = new THREE.AnimationMixer(model); // Mikser animacji\r\n                    mixers[model.userData.name].addEventListener('finished', function(e: any) {\r\n                        e.action._clip.isPlaying = false;\r\n                        console.log('animacja skonczona');\r\n                    });\r\n                },\r\n                undefined,\r\n                function(error) {\r\n                    console.error(error);\r\n                },\r\n            );\r\n\r\n            loader.load(\r\n                '/peach_castle/floor.gltf',\r\n                gltf => {\r\n                    const model = gltf.scene;\r\n                    model.userData.name = 'floor';\r\n                    model.visible = false;\r\n                    scene.add(model);\r\n\r\n                    //Zapisz dane obiektu\r\n                    objects[model.userData.name] = model; // Obiekt\r\n                },\r\n                undefined,\r\n                function(error) {\r\n                    console.error(error);\r\n                },\r\n            );\r\n\r\n            // Dodanie światła\r\n            const ambientLight = new THREE.HemisphereLight(0xffffff, 0x222222, 1);\r\n            const mainLight = new THREE.DirectionalLight(0xffffff, 4.0);\r\n            mainLight.position.set(10, 10, 10);\r\n            scene.add(ambientLight, mainLight);\r\n\r\n            // Sterowanie kamera za pomoca myszy\r\n            const controls = new OrbitControls(camera, renderer.domElement);\r\n            controls.enableDamping = true;\r\n            controls.dampingFactor = 0.05;\r\n            controls.screenSpacePanning = false;\r\n            controls.minDistance = 10;\r\n            controls.maxDistance = 500;\r\n\r\n            // Postprocessing\r\n            const composer = new EffectComposer(renderer);\r\n            const renderPass = new RenderPass(scene, camera);\r\n            composer.addPass(renderPass);\r\n            const pass = new SMAAPass(window.innerWidth * renderer.getPixelRatio(), window.innerHeight * renderer.getPixelRatio());\r\n            composer.addPass(pass);\r\n\r\n            // Funkcja renderująca\r\n            const render = () => {\r\n                renderer.render(scene, camera);\r\n            };\r\n\r\n            // Główna pętla animacji\r\n            const animate = () => {\r\n                requestAnimationFrame(animate);\r\n\r\n                if (typeof mixer !== 'undefined') {\r\n                    mixer.update(clock.getDelta());\r\n                }\r\n\r\n                for (const model in mixers) {\r\n                    mixers[model].update(clock.getDelta());\r\n                }\r\n\r\n                // Jeżeli którykolwiek klawisz jest wciśnięty\r\n                if (Object.values(pressedKeys).includes(true)) {\r\n                    const keysStateResult = checkKeysState();\r\n                    objects['Robot'].position.add(keysStateResult.move);\r\n                    objects['Robot'].rotation.y = keysStateResult.angle * (Math.PI / 180);\r\n                }\r\n\r\n                controls.update();\r\n                //composer.render(); // Render postprocessingu\r\n                render(); // Render standardowy\r\n            };\r\n\r\n            animate();\r\n        })\r\n\r\n        onUnmounted(() => {\r\n            window.removeEventListener('keydown', keyDown);\r\n            window.removeEventListener('keyup', keyUp);\r\n        })\r\n\r\n        return {camera, renderer, scene, clock, raycaster, objects, mixers, animations, pressedKeys, sceneRef, playAnimation, stopAnimation, testAllKeys, testAnyKeys, checkKeysState, robotRunning, keyUp, keyDown}\r\n    }\r\n}\r\n","import { render } from \"./Scene.vue?vue&type=template&id=549912f1&scoped=true\"\nimport script from \"./Scene.vue?vue&type=script&lang=ts\"\nexport * from \"./Scene.vue?vue&type=script&lang=ts\"\n\nimport \"./Scene.vue?vue&type=style&index=0&id=549912f1&scoped=true&lang=scss\"\nscript.render = render\nscript.__scopeId = \"data-v-549912f1\"\n\nexport default script","<template>\r\n    <div class=\"container\">\r\n        <div class=\"scene\" ref=\"sceneRef\"></div>\r\n    </div>\r\n</template>\r\n\r\n<script lang=\"ts\">\r\nimport createScene from '../hooks/createScene';\r\nimport addLights from '../hooks/addLights';\r\nimport postProduction from '../hooks/postProduction';\r\nimport addMap from '../hooks/addMap';\r\nimport addCharacter from '../hooks/addCharacter';\r\nimport keysControls from '../hooks/keysControls';\r\n\r\nimport { ref } from 'vue'\r\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\r\nimport { Vector3 } from 'three';\r\n\r\n//import * as dat from 'dat.gui';\r\n\r\nexport default {\r\n    setup() {\r\n        //const gui = new dat.GUI();\r\n\r\n        // Zmienne sceny\r\n        const characterPosition = new Vector3(5, 11.5, 0);\r\n        //const cameraOffset = new Vector3(5, 30, 50); // wektor przesunięcia kamery względem postaci\r\n        const cameraOffset = new Vector3(2.5, 15, 25);\r\n\r\n        // Dodaj scenę\r\n        const sceneRef = ref(null);\r\n        const { scene, renderer, camera, animateFunctions, animation, controls } = createScene(sceneRef, characterPosition, cameraOffset);\r\n\r\n        // Dodaj światła\r\n        addLights(scene);\r\n\r\n        // Dodaj postprodukcję\r\n        postProduction(scene, camera, renderer)\r\n\r\n        // Załaduj główną mapę\r\n        const loader = new GLTFLoader();\r\n        const objects: any = {};\r\n        addMap(loader, scene, objects, '/peach_castle/scene.gltf', '/peach_castle/floor.gltf');\r\n\r\n        // Wczytaj funkcje obsługi klawiszy i padów\r\n        const pressedKeys: any = {};\r\n\r\n        const { testAllKeys, testAnyKeys, keysFunctions, checkPressedKeys, testAllButtons, testAnyButton, testAxis, checkPads, gamepads} = keysControls(pressedKeys);\r\n        animateFunctions.push(checkPressedKeys, checkPads)\r\n\r\n        // Wczytaj postać z funkcjami ruchu i animacji\r\n        const animations: any = {};\r\n        const mixers: any = {};\r\n        const { robotRunning, toAnimate } = addCharacter(\r\n            loader, scene, objects, animations, mixers,\r\n            pressedKeys, testAllKeys, testAnyKeys,\r\n            gamepads, testAllButtons, testAnyButton, testAxis, '/Robot_edited.glb',\r\n            controls, camera, characterPosition, cameraOffset, animation\r\n        );\r\n        animateFunctions.push(toAnimate);\r\n        keysFunctions.push(robotRunning);\r\n\r\n        return {\r\n            sceneRef,\r\n            camera,\r\n            animations,\r\n            mixers\r\n        }\r\n    }\r\n}\r\n</script>\r\n\r\n<style scoped lang=\"scss\">\r\n.scene {\r\n    width: 100vw;\r\n    height: 100vh;\r\n}\r\n\r\n.info {\r\n    z-index: 999;\r\n    background-color: white;\r\n    border: 1px solid black;\r\n    position: absolute;\r\n    right: 0;\r\n    top: 0;\r\n    text-align: left;\r\n}\r\n</style>\r\n","import { onMounted, onUnmounted, ref } from 'vue';\r\nimport * as THREE from 'three';\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\nimport Stats from 'stats.js'\r\nimport { Vector3 } from 'three';\r\n\r\nexport default function createScene(sceneRef: any, characterPosition: Vector3, cameraOffset: Vector3) {\r\n    const scene: THREE.Scene = new THREE.Scene();\r\n    const renderer: THREE.WebGLRenderer = new THREE.WebGLRenderer({ antialias: true });\r\n    const camera: THREE.PerspectiveCamera = new THREE.PerspectiveCamera();\r\n    const animation = ref();\r\n    const animateFunctions: Array<any> = [];\r\n    const controls: OrbitControls = new OrbitControls(camera, renderer.domElement);\r\n\r\n    const onWindowResize = () => {\r\n        camera.aspect = window.innerWidth / window.innerHeight;\r\n        camera.updateProjectionMatrix();\r\n        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\r\n        renderer.setSize(window.innerWidth, window.innerHeight);\r\n    }\r\n\r\n    onMounted( () => {\r\n        camera.fov = 60;\r\n        camera.aspect = sceneRef.value ? sceneRef.value.clientWidth / sceneRef.value.clientHeight : window.innerWidth / window.innerHeight;\r\n        camera.near = 1;\r\n        camera.far = 1000;\r\n        camera.position.set(characterPosition.x + cameraOffset.x, characterPosition.y + cameraOffset.y, characterPosition.z + cameraOffset.z);\r\n        camera.updateProjectionMatrix();\r\n        renderer.setSize(sceneRef.value.clientWidth, sceneRef.value.clientHeight);\r\n        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\r\n        sceneRef.value.appendChild(renderer.domElement);\r\n\r\n        // zmiana rozmiaru sceny\r\n        window.addEventListener('resize', onWindowResize);\r\n\r\n        // Panel statystyk\r\n        const stats = new Stats();\r\n        stats.showPanel(0);\r\n        document.body.appendChild( stats.dom );\r\n\r\n        // Sterowanie kamera za pomoca myszy\r\n        controls.enableDamping = true;\r\n        controls.dampingFactor = 0.05;\r\n        controls.screenSpacePanning = false;\r\n        controls.minDistance = 10;\r\n        controls.maxDistance = 500;\r\n        controls.enablePan = false;\r\n        controls.enableRotate = false;\r\n        controls.enableZoom = false;\r\n        controls.target = characterPosition\r\n\r\n        // Funkcja renderująca\r\n        const render = () => {\r\n            renderer.render(scene, camera);\r\n        };\r\n\r\n        // Główna pętla animacji\r\n        const animate = () => {\r\n            stats.begin();\r\n\r\n            requestAnimationFrame(animate);\r\n            controls.update();\r\n\r\n            animateFunctions.forEach(func => {\r\n                func();\r\n            });\r\n\r\n            render();\r\n\r\n            stats.end();\r\n        };\r\n\r\n        animate();\r\n    });\r\n\r\n    onUnmounted(() => {\r\n        window.removeEventListener('resize', onWindowResize);\r\n    })\r\n\r\n    return {\r\n        scene,\r\n        renderer,\r\n        camera,\r\n        animateFunctions,\r\n        animation,\r\n        controls\r\n    };\r\n}","import { onMounted } from 'vue';\r\nimport * as THREE from 'three';\r\n\r\nexport default function addLights(scene: THREE.Scene) {\r\n\r\n    onMounted( () => {\r\n        const ambientLight = new THREE.HemisphereLight(0xffffff, 0x222222, 3.5);\r\n        const mainLight = new THREE.DirectionalLight(0xffffff, 3.0);\r\n        mainLight.position.set(10, 30, 10);\r\n\r\n        scene.add(ambientLight);\r\n    });\r\n}","import { onMounted } from 'vue';\r\nimport * as THREE from 'three';\r\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\r\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';\r\nimport { SMAAPass } from 'three/examples/jsm/postprocessing/SMAAPass.js';\r\n\r\nexport default function postProduction(scene: THREE.Scene, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer) {\r\n\r\n    onMounted( () => {\r\n        const composer = new EffectComposer(renderer);\r\n        const renderPass = new RenderPass(scene, camera);\r\n        composer.addPass(renderPass);\r\n        const pass = new SMAAPass(window.innerWidth * renderer.getPixelRatio(), window.innerHeight * renderer.getPixelRatio());\r\n        composer.addPass(pass);\r\n    });\r\n}","import { onMounted } from 'vue';\r\nimport * as THREE from 'three';\r\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\r\n\r\nexport default function addMap(loader: GLTFLoader, scene: THREE.Scene, objects: any, mapPath: string, collisionMapPath: string) {\r\n    onMounted( () => {\r\n        loader.load(\r\n            mapPath,\r\n            gltf => {\r\n                const model = gltf.scene;\r\n                scene.add(model);\r\n            },\r\n            undefined,\r\n            function(error) {\r\n                console.error(error);\r\n            },\r\n        );\r\n\r\n        loader.load(\r\n            collisionMapPath,\r\n            gltf => {\r\n                const model = gltf.scene;\r\n                model.userData.name = 'floor';\r\n                model.visible = false;\r\n                scene.add(model);\r\n\r\n                //Zapisz dane obiektu\r\n                objects[model.userData.name] = model; // Obiekt\r\n            },\r\n            undefined,\r\n            function(error) {\r\n                console.error(error);\r\n            },\r\n        );\r\n    });\r\n}","import { onMounted, Ref } from 'vue';\r\nimport * as THREE from 'three';\r\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\nimport { AnimationAction, Object3D, Vector3 } from 'three';\r\nimport anime from 'animejs';\r\n\r\nexport default function addCharacter(\r\n    loader: GLTFLoader,\r\n    scene: THREE.Scene,\r\n    objects: any,\r\n    animations: any,\r\n    mixers: any,\r\n    pressedKeys: any,\r\n    testAllKeys: any,\r\n    testAnyKeys: any,\r\n    gamepads: Ref<(Gamepad | null)[]>,\r\n    testAllButtons: any,\r\n    testAnyButton: any,\r\n    testAxis: any,\r\n    characterPath: string,\r\n    controls: OrbitControls,\r\n    camera: THREE.PerspectiveCamera,\r\n    position: Vector3,\r\n    cameraOffset: Vector3,\r\n    animation: Ref\r\n) {\r\n\r\n    const raycaster = new THREE.Raycaster();\r\n    const clock = new THREE.Clock();\r\n    let pauseOthersAnimations = false;\r\n\r\n    let currentAnimation: AnimationAction | null = null;\r\n    let oneLoopTrigger = 0\r\n\r\n    const playAnimation = (objectMixer: any, objectAnimations: any, animationName: any, acceleration = 1, loop = true) => {\r\n        const clip = objectAnimations.find((el: any) => el.name === animationName);\r\n        const animation = objectMixer.clipAction(clip);\r\n        animation.setEffectiveTimeScale(acceleration);\r\n\r\n        if(!loop && animation.time == animation.getClip().duration) {\r\n            animation.reset()\r\n        }\r\n\r\n        if (!loop && animation != currentAnimation) {\r\n            pauseOthersAnimations = true;\r\n            animation.setLoop(THREE.LoopOnce, 1);\r\n            animation.setEffectiveWeight(1).reset()\r\n            currentAnimation?.fadeOut(getFadeTime(currentAnimation, animation))\r\n            currentAnimation = animation\r\n        }\r\n\r\n        if (pauseOthersAnimations) {\r\n            if(currentAnimation && currentAnimation.time/currentAnimation.getClip().duration >= 0.75) {\r\n                pauseOthersAnimations = false\r\n                animation.fadeIn(getFadeTime(animation, currentAnimation)).reset()\r\n                currentAnimation = animation\r\n            }\r\n        } else {\r\n            animation.setEffectiveWeight(1)\r\n            currentAnimation = animation\r\n        }\r\n    }\r\n\r\n    const getFadeTime = (startAnimation: AnimationAction, endAnimation: AnimationAction) => {\r\n        const startAnimationTime = startAnimation.getClip().duration / startAnimation.getEffectiveTimeScale()\r\n        const endAnimationTime = endAnimation.getClip().duration / endAnimation.getEffectiveTimeScale()\r\n\r\n        if (endAnimationTime * 0.25 > startAnimationTime) {\r\n            return startAnimationTime\r\n        } else {\r\n            return endAnimationTime * 0.25\r\n        }\r\n    }\r\n\r\n    const stopAnimation = (objectMixer: any, objectAnimations: any, animationName: any) => {\r\n        const clip = objectAnimations.find((el: any) => el.name === animationName);\r\n        const animation = objectMixer.clipAction(clip);\r\n        animation.setEffectiveWeight(0)\r\n    }\r\n\r\n    const updateCameraPosition = () => {\r\n        animation.value = anime({\r\n            targets: camera.position,\r\n            easing: 'easeOutCirc',\r\n            duration: 1000,\r\n            complete: () => {\r\n                animation.value = null;\r\n            },\r\n            x: objects['Robot'].position.x + cameraOffset.x,\r\n            y: objects['Robot'].position.y + cameraOffset.y,\r\n            z: objects['Robot'].position.z + cameraOffset.z\r\n        });\r\n\r\n        animation.value = anime({\r\n            targets: controls.target,\r\n            easing: 'easeOutCirc',\r\n            duration: 2000,\r\n            complete: () => {\r\n                animation.value = null;\r\n            },\r\n            x: objects['Robot'].position.x,\r\n            y: objects['Robot'].position.y,\r\n            z: objects['Robot'].position.z,\r\n        });\r\n    }\r\n\r\n    const checkKeysState = () => {\r\n        const robotPosition = objects['Robot'].position.clone()\r\n        const robotRotation = objects['Robot'].rotation.y * 180 / Math.PI\r\n        const skeletonExtremes = getSkeletonExtremes(objects['Robot'])\r\n        const robotHeight = skeletonExtremes.max.y-skeletonExtremes.min.y // wysokość postaci\r\n        const raycasterPosition = robotPosition.clone()\r\n        raycasterPosition.y += robotHeight;\r\n        let speed = 0.18;\r\n        const horizontalOffset = 1; // powinien wynosić promień poziomy postaci\r\n        const distanceLimitUp = 1.2; // limit wielkości na jaką może wejść (bez skoku)\r\n        const distanceLimitDown = 5; // limit wielkości z jakiej może zejść\r\n        let angle = robotRotation;\r\n        const move = new THREE.Vector3();\r\n        const oneLoop = currentAnimation?.loop == 2200\r\n        const axis = testAxis()\r\n\r\n        // const robotPositionHelper = new THREE.Mesh(new THREE.SphereGeometry( 0.1, 8, 8 ), new THREE.MeshBasicMaterial( {color: 0xff0000} ));\r\n        // robotPositionHelper.position.set(robotPosition.x, robotPosition.y, robotPosition.z)\r\n        // scene.add(robotPositionHelper)\r\n        // setTimeout(() => {\r\n        //     scene.remove(robotPositionHelper)\r\n        // }, 300);\r\n\r\n        if ((testAllKeys(['ShiftLeft']) || testAllButtons([7])) && !oneLoop) {\r\n            speed *= 2;\r\n        }\r\n\r\n        if (testAllKeys(['KeyW'], ['KeyA', 'KeyS', 'KeyD']) || testAllButtons([12], [13,14,15])) {\r\n            angle = 180;\r\n            move.z = -1 * speed;\r\n            raycasterPosition.z += -1 * speed - horizontalOffset;\r\n        } else if (testAllKeys(['KeyA'], ['KeyW', 'KeyS', 'KeyD']) || testAllButtons([14], [12,13,15])) {\r\n            angle = -90;\r\n            move.x = -1 * speed;\r\n            raycasterPosition.x += -1 * speed - horizontalOffset;\r\n        } else if (testAllKeys(['KeyS'], ['KeyW', 'KeyA', 'KeyD']) || testAllButtons([13], [12,14,15])) {\r\n            angle = 0;\r\n            move.z = 1 * speed;\r\n            raycasterPosition.z += 1 * speed + horizontalOffset;\r\n        } else if (testAllKeys(['KeyD'], ['KeyW', 'KeyA', 'KeyS']) || testAllButtons([15], [12,13,14])) {\r\n            angle = 90;\r\n            move.x = 1 * speed;\r\n            raycasterPosition.x += 1 * speed + horizontalOffset;\r\n        } else if (testAllKeys(['KeyW', 'KeyA']) || testAllButtons([12, 14])) {\r\n            angle = -135;\r\n            move.x = -1 * speed;\r\n            move.z = -1 * speed;\r\n            raycasterPosition.x += -1 * speed - horizontalOffset;\r\n            raycasterPosition.z += -1 * speed - horizontalOffset;\r\n        } else if (testAllKeys(['KeyW', 'KeyD']) || testAllButtons([12, 15])) {\r\n            angle = 135;\r\n            move.x = 1 * speed;\r\n            move.z = -1 * speed;\r\n            raycasterPosition.x += 1 * speed + horizontalOffset;\r\n            raycasterPosition.z += -1 * speed - horizontalOffset;\r\n        } else if (testAllKeys(['KeyS', 'KeyA']) || testAllButtons([13, 14])) {\r\n            angle = -45;\r\n            move.x = -1 * speed;\r\n            move.z = 1 * speed;\r\n            raycasterPosition.x += -1 * speed - horizontalOffset;\r\n            raycasterPosition.z += 1 * speed + horizontalOffset;\r\n        } else if (testAllKeys(['KeyS', 'KeyD']) || testAllButtons([13, 15])) {\r\n            angle = 45;\r\n            move.x = 1 * speed;\r\n            move.z = 1 * speed;\r\n            raycasterPosition.x += 1 * speed + horizontalOffset;\r\n            raycasterPosition.z += 1 * speed + horizontalOffset;\r\n        }\r\n\r\n        if(axis) {\r\n            angle = axis.angle\r\n            move.x = axis.x * speed\r\n            move.z = axis.z * speed\r\n            raycasterPosition.x += axis.x * speed + (axis.x > 0? horizontalOffset : -horizontalOffset);\r\n            raycasterPosition.z += axis.z * speed + (axis.z > 0? horizontalOffset : -horizontalOffset);\r\n        }\r\n\r\n        updateCameraPosition()\r\n        const rotationRange = Math.abs(robotRotation - angle)\r\n        if(oneLoop && rotationRange > 45 && rotationRange < 315) {\r\n            angle = robotRotation\r\n            move.x = 0\r\n            move.z = 0\r\n        }\r\n\r\n        // Wykrywanie kolizji\r\n        raycaster.set(raycasterPosition, new THREE.Vector3(0, -1, 0));\r\n        const intersects = raycaster.intersectObject(objects['floor'], true);\r\n\r\n        // Pokazuje promienie raycastera\r\n        // const raycasterHelper = new THREE.ArrowHelper(raycaster.ray.direction, raycaster.ray.origin, robotHeight, 0xff00ff)\r\n        // scene.add(raycasterHelper);\r\n        // setTimeout(() => {scene.remove(raycasterHelper)}, 3000);\r\n\r\n        // Odległość od raycastera do najniższej części robota\r\n        const rayToRobotDistance = Math.abs(skeletonExtremes.min.y - robotPosition.y)\r\n        // const rayToRobotDistanceHelper = new THREE.ArrowHelper(new Vector3(0, 1, 0), robotPosition, rayToRobotDistance, 0xff0000, 0, 0)\r\n        // rayToRobotDistanceHelper.renderOrder = 9999\r\n        // scene.add(rayToRobotDistanceHelper)\r\n        // setTimeout(() => {\r\n        //     scene.remove(rayToRobotDistanceHelper)\r\n        // }, 3000);\r\n\r\n        // Odległość od kolizji do pozycji Robota\r\n        const collistionToRobotTop = intersects[0] ? intersects[0].distance - robotHeight : 0\r\n\r\n        // Sprawdza czy poruszamy sie w dół czy do góry\r\n        const goUp = collistionToRobotTop >= 0 ? false : true\r\n\r\n        if(intersects[0]) {\r\n            // const collistionToRobotTopPosition = intersects[0].point.clone()\r\n            // collistionToRobotTopPosition.x += 0.01\r\n            // collistionToRobotTopPosition.z += 0.01\r\n            // const collistionToRobotTopHelper = new THREE.ArrowHelper(new Vector3(0, goUp? -1 : 1, 0), collistionToRobotTopPosition, Math.abs(collistionToRobotTop), 0xffff00, 0, 0)\r\n            // collistionToRobotTopHelper.renderOrder = 99999\r\n            // scene.add(collistionToRobotTopHelper)\r\n            // setTimeout(() => {\r\n            //     scene.remove(collistionToRobotTopHelper)\r\n            // }, 3000);\r\n        }\r\n\r\n        if (intersects[0] && Math.abs(collistionToRobotTop) < distanceLimitUp + rayToRobotDistance && goUp) {\r\n            if(oneLoop) {\r\n                if(rayToRobotDistance >= Math.abs(collistionToRobotTop)) {\r\n                    move.y = 0\r\n                } else {\r\n                    if (oneLoopTrigger < Math.abs(collistionToRobotTop + rayToRobotDistance)) {\r\n                        move.y = Math.abs(collistionToRobotTop + rayToRobotDistance)\r\n                        if(currentAnimation) currentAnimation.warp(currentAnimation.timeScale, currentAnimation.timeScale*4, currentAnimation.getClip().duration-currentAnimation.time)\r\n                    } else {\r\n                        move.y = 0\r\n                    }\r\n                }\r\n\r\n                oneLoopTrigger = Math.abs(collistionToRobotTop + rayToRobotDistance)\r\n                return { move, angle };\r\n            } else {\r\n                oneLoopTrigger = 0\r\n                move.y = -intersects[0].distance + robotHeight;\r\n                return { move, angle };\r\n            }\r\n        } else if(intersects[0] && collistionToRobotTop < distanceLimitDown && !goUp) {\r\n            move.y = -intersects[0].distance + robotHeight;\r\n            return { move, angle };\r\n        } else {\r\n            move.x = 0;\r\n            move.y = 0;\r\n            move.z = 0;\r\n            return { move, angle};\r\n        }\r\n    }\r\n\r\n    const robotRunning = () => {\r\n        if (mixers['Robot']) {\r\n            if (testAnyKeys(['KeyW', 'KeyA', 'KeyS', 'KeyD']) || testAnyButton([12,13,14,15]) || testAxis()) {\r\n                let acceleration = 1;\r\n                if (testAllKeys(['ShiftLeft']) || testAllButtons([7])) {\r\n                    acceleration = 2;\r\n                }\r\n                playAnimation(mixers['Robot'], animations['Robot'], 'Robot_Running', acceleration);\r\n            } else {\r\n                stopAnimation(mixers['Robot'], animations['Robot'], 'Robot_Running');\r\n            }\r\n\r\n            if (testAnyKeys(['Space']) || testAllButtons([0])) {\r\n                playAnimation(mixers['Robot'], animations['Robot'], 'Robot_Jump', 0.6, false);\r\n            }\r\n\r\n            // if (testAnyKeys(['ArrowUp'])) {\r\n            //     const skeletonExtremes = getSkeletonExtremes(objects['Robot'])\r\n\r\n            //     const newhelper = new THREE.Mesh(new THREE.PlaneGeometry( 3, 3, 1 ), new THREE.MeshBasicMaterial( {color: 0xff0000, side: THREE.DoubleSide} ));\r\n            //     newhelper.rotateX(Math.PI * 0.5)\r\n            //     newhelper.position.set(objects['Robot'].position.x, skeletonExtremes.min.y, objects['Robot'].position.z)\r\n            //     scene.add(newhelper)\r\n            //     setTimeout(() => {\r\n            //         scene.remove(newhelper)\r\n            //     }, 3);\r\n\r\n            //     const newhelper2 = new THREE.Mesh(new THREE.PlaneGeometry( 3, 3, 1 ), new THREE.MeshBasicMaterial( {color: 0xffff00, side: THREE.DoubleSide} ));\r\n            //     newhelper2.rotateX(Math.PI * 0.5)\r\n            //     newhelper2.position.set(objects['Robot'].position.x, skeletonExtremes.max.y, objects['Robot'].position.z)\r\n            //     scene.add(newhelper2)\r\n            //     setTimeout(() => {\r\n            //         scene.remove(newhelper2)\r\n            //     }, 3);\r\n            // }\r\n        }\r\n    }\r\n\r\n    const toAnimate = () => {\r\n        for (const model in mixers) {\r\n            mixers[model].update(clock.getDelta());\r\n        }\r\n\r\n        // Jeżeli którykolwiek klawisz jest wciśnięty\r\n        if (Object.values(pressedKeys).includes(true) || pauseOthersAnimations || gamepads.value[0]) {\r\n            const keysStateResult = checkKeysState();\r\n            objects['Robot'].position.add(keysStateResult.move);\r\n            objects['Robot'].rotation.y = keysStateResult.angle * (Math.PI / 180);\r\n        }\r\n    }\r\n\r\n    const getSkeletonExtremes = (object: THREE.Object3D) => {\r\n        const skeleton = new THREE.SkeletonHelper(object)\r\n        const bone_min = {x:Infinity,y:Infinity,z:Infinity};\r\n        const bone_max = {x:-Infinity,y:-Infinity,z:-Infinity};\r\n\r\n        for(let b=0; b < skeleton.bones.length; b++){\r\n            const child = skeleton.bones[b];\r\n            const position = new THREE.Vector3();\r\n            child.getWorldPosition(position);\r\n\r\n            if(position.x < bone_min.x) bone_min.x = position.x\r\n            if(position.y < bone_min.y) bone_min.y = position.y\r\n            if(position.z < bone_min.z) bone_min.z = position.z\r\n\r\n            if(position.x > bone_max.x) bone_max.x = position.x\r\n            if(position.y > bone_max.y) bone_max.y = position.y\r\n            if(position.z > bone_max.z) bone_max.z = position.z\r\n        }\r\n\r\n        return {min: bone_min, max: bone_max}\r\n    }\r\n\r\n    onMounted( () => {\r\n        loader.load(\r\n            characterPath,\r\n            gltf => {\r\n                const model = gltf.scene;\r\n                model.userData.name = 'Robot';\r\n                model.position.set(position.x, position.y, position.z);\r\n                scene.add(model);\r\n\r\n                //Zapisz dane obiektu\r\n                objects[model.userData.name] = model; // Obiekt\r\n                animations[model.userData.name] = gltf.animations; // Animacja\r\n                mixers[model.userData.name] = new THREE.AnimationMixer(model); // Mikser animacji\r\n                mixers[model.userData.name].addEventListener('finished', function(e: any) {\r\n                    pauseOthersAnimations = false;\r\n                    robotRunning()\r\n                    //console.log('animacja '+ e.action._clip.name +' skonczona');\r\n                });\r\n                animations[model.userData.name].forEach((animation: THREE.AnimationClip) => {\r\n                    mixers[model.userData.name].clipAction(animation).setEffectiveWeight(0).play()\r\n                });\r\n            },\r\n            undefined,\r\n            function(error) {\r\n                console.error(error);\r\n            },\r\n        );\r\n    });\r\n\r\n    return {\r\n        robotRunning,\r\n        toAnimate\r\n    }\r\n}","import { onUnmounted, ref, Ref } from 'vue';\r\n\r\nexport default function keysControls(pressedKeys: any) {\r\n\r\n    const keysFunctions: Array<any> = [];\r\n    const gamepads: Ref<(Gamepad | null)[]> = ref([]);\r\n\r\n    const keyUp = (e: any) => {\r\n        pressedKeys[e.code] = false;\r\n    }\r\n\r\n    const keyDown = (e: any) => {\r\n        pressedKeys[e.code] = true;\r\n    }\r\n\r\n    const connectGamepad = (e: any) => {\r\n        console.log(e.gamepad.id, 'podłączony')\r\n    }\r\n\r\n    const disconectGamepad = (e: any) => {\r\n        console.log(e.gamepad.id, 'odłączony')\r\n    }\r\n\r\n    const checkPads = () => {\r\n        gamepads.value = navigator.getGamepads()\r\n    }\r\n\r\n    const checkPressedKeys = () => {\r\n        keysFunctions.forEach(func => { func() });\r\n    }\r\n\r\n    window.addEventListener('keydown', keyDown);\r\n    window.addEventListener('keyup', keyUp);\r\n    window.addEventListener(\"gamepadconnected\", connectGamepad);\r\n    window.addEventListener(\"gamepaddisconnected\", disconectGamepad)\r\n\r\n    const testAllKeys = (keysArray: any, exceptionKeysArray: any = null) => {\r\n        const activeInArray = keysArray.every((e: any) => pressedKeys[e] === true); // Czy klawisze z listy są wciąnięte\r\n        if (exceptionKeysArray) {\r\n            const exceptionInArray = exceptionKeysArray.every((e: any) => pressedKeys[e] === false || pressedKeys[e] === undefined);\r\n            return activeInArray && exceptionInArray;\r\n        }\r\n        return activeInArray;\r\n    };\r\n\r\n    const testAnyKeys = (keysArray: any) => {\r\n        return keysArray.some((e: any) => pressedKeys[e] === true);\r\n    };\r\n\r\n    const testAllButtons = (buttonsArray: any, exceptionKeysArray: any = null) => {\r\n        const activeInArray = buttonsArray.every((button: any) => gamepads.value[0]?.buttons[button].pressed)\r\n        if (exceptionKeysArray) {\r\n            const exceptionInArray = exceptionKeysArray.every((button: any) => !gamepads.value[0]?.buttons[button].pressed);\r\n            return activeInArray && exceptionInArray;\r\n        }\r\n        return activeInArray;\r\n    }\r\n\r\n    const testAxis = () => {\r\n        if(gamepads.value[0]) {\r\n            const axisTolerance = 0.3\r\n            const a0 = gamepads.value[0]?.axes[0] \r\n            const a1 = gamepads.value[0]?.axes[1]\r\n            const angle = Math.atan2(a1, -a0) * 180 / Math.PI;\r\n\r\n            const result = {\r\n                angle: angle - 90,\r\n                x: a0,\r\n                z: a1\r\n            }\r\n\r\n            if(Math.abs(a0) > axisTolerance || Math.abs(a1) > axisTolerance) return result\r\n        }\r\n    }\r\n\r\n    const testAnyButton = (buttonsArray: any) => {\r\n        return buttonsArray.some((button: any) => gamepads.value[0]?.buttons[button].pressed);\r\n    };\r\n\r\n    onUnmounted(() => {\r\n        window.removeEventListener('keydown', keyDown);\r\n        window.removeEventListener('keyup', keyUp);\r\n        window.removeEventListener(\"gamepadconnected\", connectGamepad);\r\n        window.addEventListener(\"gamepaddisconnected\", disconectGamepad)\r\n    })\r\n\r\n    return {\r\n        testAllKeys,\r\n        testAnyKeys,\r\n        keysFunctions,\r\n        checkPressedKeys,\r\n        testAllButtons,\r\n        testAnyButton,\r\n        testAxis,\r\n        checkPads,\r\n        gamepads\r\n    }\r\n}\r\n","\r\nimport createScene from '../hooks/createScene';\r\nimport addLights from '../hooks/addLights';\r\nimport postProduction from '../hooks/postProduction';\r\nimport addMap from '../hooks/addMap';\r\nimport addCharacter from '../hooks/addCharacter';\r\nimport keysControls from '../hooks/keysControls';\r\n\r\nimport { ref } from 'vue'\r\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\r\nimport { Vector3 } from 'three';\r\n\r\n//import * as dat from 'dat.gui';\r\n\r\nexport default {\r\n    setup() {\r\n        //const gui = new dat.GUI();\r\n\r\n        // Zmienne sceny\r\n        const characterPosition = new Vector3(5, 11.5, 0);\r\n        //const cameraOffset = new Vector3(5, 30, 50); // wektor przesunięcia kamery względem postaci\r\n        const cameraOffset = new Vector3(2.5, 15, 25);\r\n\r\n        // Dodaj scenę\r\n        const sceneRef = ref(null);\r\n        const { scene, renderer, camera, animateFunctions, animation, controls } = createScene(sceneRef, characterPosition, cameraOffset);\r\n\r\n        // Dodaj światła\r\n        addLights(scene);\r\n\r\n        // Dodaj postprodukcję\r\n        postProduction(scene, camera, renderer)\r\n\r\n        // Załaduj główną mapę\r\n        const loader = new GLTFLoader();\r\n        const objects: any = {};\r\n        addMap(loader, scene, objects, '/peach_castle/scene.gltf', '/peach_castle/floor.gltf');\r\n\r\n        // Wczytaj funkcje obsługi klawiszy i padów\r\n        const pressedKeys: any = {};\r\n\r\n        const { testAllKeys, testAnyKeys, keysFunctions, checkPressedKeys, testAllButtons, testAnyButton, testAxis, checkPads, gamepads} = keysControls(pressedKeys);\r\n        animateFunctions.push(checkPressedKeys, checkPads)\r\n\r\n        // Wczytaj postać z funkcjami ruchu i animacji\r\n        const animations: any = {};\r\n        const mixers: any = {};\r\n        const { robotRunning, toAnimate } = addCharacter(\r\n            loader, scene, objects, animations, mixers,\r\n            pressedKeys, testAllKeys, testAnyKeys,\r\n            gamepads, testAllButtons, testAnyButton, testAxis, '/Robot_edited.glb',\r\n            controls, camera, characterPosition, cameraOffset, animation\r\n        );\r\n        animateFunctions.push(toAnimate);\r\n        keysFunctions.push(robotRunning);\r\n\r\n        return {\r\n            sceneRef,\r\n            camera,\r\n            animations,\r\n            mixers\r\n        }\r\n    }\r\n}\r\n","import { render } from \"./NewScene.vue?vue&type=template&id=4d3d209c&scoped=true\"\nimport script from \"./NewScene.vue?vue&type=script&lang=ts\"\nexport * from \"./NewScene.vue?vue&type=script&lang=ts\"\n\nimport \"./NewScene.vue?vue&type=style&index=0&id=4d3d209c&scoped=true&lang=scss\"\nscript.render = render\nscript.__scopeId = \"data-v-4d3d209c\"\n\nexport default script","\nimport { Options, Vue } from 'vue-class-component';\nimport Scene from '../components/Scene.vue';\nimport NewScene from '../components/NewScene.vue';\n\n@Options({\n    components: {\n        Scene, NewScene\n    },\n})\nexport default class App extends Vue {}\n","import { render } from \"./Home.vue?vue&type=template&id=c1e5622a\"\nimport script from \"./Home.vue?vue&type=script&lang=ts\"\nexport * from \"./Home.vue?vue&type=script&lang=ts\"\nscript.render = render\n\nexport default script","import { createRouter, createWebHistory, RouteRecordRaw } from 'vue-router'\nimport Home from '../views/Home.vue'\n\nconst routes: Array<RouteRecordRaw> = [\n    {\n        path: '/',\n        name: 'Home',\n        component: Home\n    }\n]\n\nconst router = createRouter({\n    history: createWebHistory(process.env.BASE_URL),\n    routes\n})\n\nexport default router\n","import { createStore } from 'vuex'\n\nexport default createStore({\n    state: {\n    },\n    mutations: {\n    },\n    actions: {\n    },\n    modules: {\n    }\n})\n","import { createApp } from 'vue'\r\nimport App from './App.vue'\r\nimport router from './router'\r\nimport store from './store'\r\n\r\ncreateApp(App).use(store).use(router).mount('#app')\r\n"],"sourceRoot":""}